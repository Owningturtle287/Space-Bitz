<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
<!-- Updated version stamp -->
<title>Space Bitz — v0.0.95</title>
<style>
  :root {
    --ui-bg: #0e0e13cc;
    --ui-fg: #e7f0ff;
    --ui-accent: #64e1ff;
    --ui-green: #5effa1;
    --ui-purple: #8d6bff;
    --health: #ff3b30;
    --hud-h: 108px;
   --joy-left: 50; --joy-v-offset: 125px; }
  html, body { margin:0; padding:0; background:#05060a; height:100%; touch-action:none; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; color:var(--ui-fg); }
  #game { display:block; width:100vw; height: 100vh; image-rendering: pixelated; background: transparent; }
  #topbar {position:fixed; top:calc(env(safe-area-inset-top)); left:env(safe-area-inset-left); right:env(safe-area-inset-right); z-index:12; display:flex; justify-content:space-between; align-items:flex-start; padding:6px 8px; pointer-events:none; background: transparent;}
  #topLeft { display:flex; flex-direction:column; gap:4px; align-items:flex-start; }
  #locLabel { font-size:12px; color:#a7c8ff; letter-spacing:.2px; padding:2px 4px; background:#0b0f1fb8; border:1px solid #1b254a; border-radius:8px; }
  #coords { font-size: 12px; color:#fff; padding:2px 4px; letter-spacing:.2px; }
  #healthWrap { display:flex; align-items:center; gap:8px; padding-right:6px; pointer-events:none; }
  
  .seg { width:8px; height:8px; border-radius:2px; background:#0f183e; box-shadow:inset 0 0 0 1px #0c1022; }
  .seg.filled { background: linear-gradient(180deg, #ff9a8f, var(--health)); }
  #hud { position:fixed; left:0; right:0; bottom:0; height:var(--hud-h); background: transparent;  display:grid; grid-template-rows:auto 1fr; padding:6px 12px calc(16px + env(safe-area-inset-bottom)); box-sizing:border-box; z-index:15; gap:6px; }
  #actionsRow { display:flex; align-items:center; justify-content:space-between; gap:10px; }
  .leftActions, .rightActions { display:flex; gap:8px; align-items:center; }
  .btn { -webkit-tap-highlight-color:transparent; padding:8px 12px; font-size:13px; font-weight:800; letter-spacing:.3px; border-radius:12px; outline:none; border:2px solid #2a3050; color:#e8f1ff; background: linear-gradient(180deg, rgba(12,17,48,.35), rgba(10,14,36,.25)); box-shadow: inset 0 0 0 1px #1a2260, 0 3px 0 #070a18, 0 0 0 2px rgba(94,225,255,.12); white-space:nowrap; }
  #actionMain { min-width:110px; border-color: var(--ui-purple); }
  #warpBtn { border-color:#12638a; min-width:110px; }
  #enterBtn { border-color:#1c8a4c; min-width:126px; padding:8px 10px; }
  #renameBtn { border-color:#395988; min-width:110px; }
  #inventory { display:grid; grid-template-columns: repeat(5, 44px) auto auto; gap:8px; align-items:end; }
  .slot { width:44px; height:44px; border:2px solid #4450b1; border-radius:10px; background: linear-gradient(180deg, rgba(12,17,48,.35), rgba(10,14,36,.25)); box-shadow: inset 0 0 0 1px #1a2260, 0 2px 0 #070a18; display:grid; place-items:center; color:#cbd7ff; font-size:9px; text-shadow:0 1px 0 #000; }
  .slot.more { font-weight:900; font-size:18px; }
  #joystick { position:fixed;   width:60px; height:60px; border-radius:50%; background: radial-gradient(70px 70px at 50% 50%, rgba(100,140,255,.12), rgba(0,0,0,.0)); border:1px solid #283258; pointer-events:auto; display:none; z-index:14; touch-action:none;      left: calc(var(--joy-left,50) * 1%); top: calc(100vh - var(--hud-h) - var(--joy-v-offset,28px)); transform: translate(-50%, 0); }

  #stick { position:absolute; width:26px; height:26px; border-radius:50%; left:50%; top:50%; background:#0b0f1f; border:2px solid #3a4bb0; box-shadow: inset 0 0 0 1px #1a2260, 0 3px 0 #070a18;  transform: translate(calc(-50% + var(--dx, 0px)), calc(-50% + var(--dy, 0px))); will-change: left, top, transform; }
  #startOverlay { position:fixed; inset:0; z-index:50; display:grid; place-items:center; padding:max(20px, env(safe-area-inset-top)) 16px max(20px, env(safe-area-inset-bottom)); overflow:hidden; }
  #startOverlay canvas.bg { position:absolute; inset:0; width:100%; height:100%; z-index:0; background:#03040a; }
  #startOverlay, #startOverlay * { touch-action:auto; }
  #menuWrap { position:absolute; top:50%; left:52%; transform:translate(-50%, -50%); width:min(680px, 92vw); z-index:1; }
  .title { font-family:"Press Start 2P", ui-monospace, monospace; font-size:clamp(28px, 9vw, 60px); letter-spacing:2px; color:#e7f7ff; text-shadow:0 1px 0 #0a0e20, 0 2px 0 #0a0e20, 0 3px 0 #0a0e20, 0 0 16px rgba(94,225,255,.6), 0 0 32px rgba(94,225,255,.3); margin:0 0 8px 4px; text-align:left; }
  .ver { margin-left:6px; font-size:12px; color:#9cd8ff; opacity:.9; }
  .panel { background: rgba(9, 12, 24, .92); border:1px solid #4b59a9; border-radius:16px; box-shadow:0 20px 40px rgba(0,0,0,.45), inset 0 0 0 1px #0c1022; padding:12px; display:grid; gap:12px; }
  .grid2 { display:grid; grid-template-columns:minmax(0,1fr) minmax(0,1fr); gap:12px; }
  .field { display:grid; gap:4px; }
  label { font-size:12px; color:#d9e1ff; }
  input[type="text"] { width:100%; padding:8px 10px; border-radius:10px; box-sizing:border-box; background:#0a0f25; color:#fff; border:2px solid #76c6ff; font-size:14px; box-shadow:0 0 0 1px rgba(118,198,255,.25) inset; }
  .btnL { -webkit-tap-highlight-color:transparent; min-height:42px; padding:8px 12px; border-radius:12px; border:2px solid #4b59a9; background:#0b0f1f; color:#e7f0ff; font-weight:800; letter-spacing:.3px; box-shadow: inset 0 0 0 1px #0c1022, 0 4px 0 #0a0c19; }
  .btnDangerOutline { border-color:#ff4d4f !important; box-shadow: inset 0 0 0 1px rgba(255,77,79,0.35), 0 2px 0 #2a0b0b; }

  .row { display:flex; gap:8px; align-items:center; justify-content:flex-end; }
  .muted { color:#b3c2ff; font-size:12px; }
  .saves { display:grid; gap:8px; max-height:36vh; overflow:auto; }
  .saveItem { display:grid; grid-template-columns:1fr auto; gap:8px; align-items:center; background:#0b0f1f; border:1px solid #2a3050; border-radius:12px; padding:10px; box-shadow: inset 0 0 0 1px #0c1022; }
  .saveTitle { font-weight:800; }
  .saveMeta { color:#a0afd8; font-size:12px; letter-spacing:.2px; }
  .saveBtns { display:flex; gap:8px; }
  .danger { border-color:#5f1b1b; }
  #invOverlay { position:fixed; inset:0; display:none; place-items:center; z-index:60; background: radial-gradient(800px 600px at 50% 100%, rgba(100, 140, 255, .15), transparent 70%), rgba(0,0,0,.5); }
  #invPanel { background:#0b0f1f; border:2px solid #4b59a9; border-radius:16px; padding:12px; box-shadow:0 20px 40px rgba(0,0,0,.45), inset 0 0 0 1px #0c1022; }
  #invGrid { display:grid; grid-template-columns:repeat(5, 56px); grid-auto-rows:56px; gap:10px; }
  #toast { position: fixed; left: 50%; top: 72px; transform: translateX(-50%); padding: 10px 14px; background: #0b0f1fb8; color: #eaf2ff; font-family: "Lucida Console", "Courier New", monospace; font-size: 14px; text-align:center; image-rendering: pixelated; letter-spacing: 0.5px; border: 2px solid #1b254a; box-shadow: 0 0 0 2px #0a0f22 inset, 0 6px 14px rgba(0,0,0,.35); border-radius: 8px; opacity:0; transition: opacity .18s ease; pointer-events:none; z-index:50; }
  #toast.show { opacity: 1; }
  /* Anim overlay */
  #animLayer { position:fixed; inset:0; pointer-events:none; z-index:13; }
  #animLayer canvas { width:100%; height:100%; image-rendering:pixelated; }
  /* SVG heart wrapper */
  #heartWrap { width:14px; height:14px; display:grid; place-items:center; }
  #heartWrap svg { width:14px; height:14px; display:block; }

  /* Hide HUD/topbar/joystick while menu is open */
  body.menuOpen #hud, body.menuOpen #topbar, body.menuOpen #joystick { display:none !important; }
  #densitySlider { accent-color: var(--ui-accent); }
  #settingsBtn { min-width:40px; padding:6px 10px; }

  /* Info buttons + overlay */
  .btn.infoMini { padding:4px 8px; font-size:12px; line-height:1; }
  #infoBtnStar, #infoBtnBody { position:fixed; z-index:16; display:none; }
  #infoOverlay { position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:56; background: radial-gradient(800px 600px at 50% 100%, rgba(100, 140, 255, .15), transparent 70%), rgba(0,0,0,.5); }
  #infoPanel { background:#0b0f1f; border:2px solid #4b59a9; border-radius:16px; padding:12px; box-shadow:0 20px 40px rgba(0,0,0,.45), inset 0 0 0 1px #0c1022; min-width:260px; max-width:90vw; }

#topLeft .pill, #locLabel{ background: rgba(12,16,36,.35); border:1px solid rgba(46,60,120,.6); border-radius:12px; padding:6px 10px;
  box-shadow: inset 0 0 0 1px rgba(12,16,34,.85), 0 1px 4px rgba(0,0,0,.25); }
#coords, #fpsLabel{ color:#dbe6ff; text-shadow: 0 1px 0 rgba(0,0,0,.6); }

/* v0.0.75 additions */
#locLabel .loc-path{line-height:1.15}
#locLabel .loc-time{display:block; margin-top:2px; opacity:.95; font-variant-numeric:tabular-nums}
.dot{display:inline-block; width:8px; height:8px; border-radius:50%; margin-right:6px; box-shadow:0 0 4px rgba(255,255,255,.3)}
.dot.star{background:#ffd26a} .dot.planet{background:#6aff7a} .dot.moon{background:#ffffff}

/* v0.0.75 UI unify + embed meta line */
#topLeft #coords, #topLeft #fps{ display: none !important }
#locLabel, #locLabel *{ color:#fff !important; }
#locLabel{ padding:8px 12px; border-radius:12px; background:rgba(0,0,0,0.55); box-shadow:0 0 0 1px rgba(255,255,255,0.06) inset, 0 6px 18px rgba(0,0,0,0.35); }
#locLabel .loc-meta{ display:block; margin-top:2px; opacity:.92; font-variant-numeric:tabular-nums; }

/* v0.0.75 health bar polish */
#healthWrap{ position:fixed; top:calc(env(safe-area-inset-top) + 8px); right:8px; left:auto; display:flex; flex-direction:column; align-items:center; gap:8px; pointer-events:none; }
#healthBar{ display:flex !important; flex-direction:column; background:rgba(12,16,34,.35); border-radius:12px; padding:8px 6px; box-shadow:0 0 0 1px rgba(255,255,255,.06) inset, 0 8px 24px rgba(0,0,0,.35); }
#healthBar .seg{ width:12px; height:16px; margin:2px 0; border-radius:6px; background:#0f1830; box-shadow:inset 0 0 0 1px rgba(255,255,255,.08); }
#healthBar .seg.filled{ background:linear-gradient(180deg, #ff6a6a, #d61a1a); box-shadow:inset 0 0 0 1px rgba(255,255,255,.12), 0 0 6px rgba(255,80,80,.45); }
#heartWrap{ order:-1; transform:translateY(0); }

/* v0.0.75 E: unify top-left fonts, force white */
#locLabel, #locLabel * { color:#fff !important; font-family: inherit !important; }

/* v0.0.75 E: hide old coord/fps lines and style the black label */
#topLeft #coords, #topLeft #fps{ display: none !important }
#locLabel{ padding:8px 12px; border-radius:12px; background:rgba(0,0,0,0.60); box-shadow:0 0 0 1px rgba(255,255,255,0.07) inset, 0 6px 18px rgba(0,0,0,0.35); }
#locLabel .loc-meta{ display:block; margin-top:2px; opacity:.92; font-variant-numeric:tabular-nums; }

/* v0.0.77b: Change Log chip (single icon) */
.chipBtn{
  --h: 22px;
  display:inline-flex; align-items:center; gap:6px;
  height:var(--h); padding:0 8px;
  border:1px solid rgba(120,140,220,.35);
  border-radius:10px;
  background:linear-gradient(180deg, rgba(18,24,52,.95), rgba(10,16,38,.95));
  color:#cfe1ff; font: 10px/1 "Press Start 2P", ui-monospace, monospace;
  letter-spacing:.02em;
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 1px 0 rgba(0,0,0,.6);
  cursor:pointer; user-select:none;
}
.chipBtn:hover{ filter:brightness(1.08); }
.chipBtn:active{ transform: translateY(1px); }
.chipBtn::before{
  content:"";
  width:12px; height:12px;
  display:inline-block;
  image-rendering: pixelated;
  background-repeat:no-repeat; background-size:contain;
  background-image: url('data:image/svg+xml;utf8,\
<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" shape-rendering="crispEdges">\
<rect width="12" height="12" fill="none"/>\
<rect x="1" y="1" width="9" height="10" fill="%23ffffff"/>\
<rect x="1" y="10" width="9" height="1" fill="%23dfe6ff"/>\
<rect x="9" y="1" width="1" height="3" fill="%23c7d2ff"/>\
<rect x="9" y="4" width="1" height="7" fill="%23b7c6ff"/>\
<rect x="8" y="1" width="1" height="1" fill="%23eaf0ff"/>\
<rect x="9" y="1" width="2" height="2" fill="%23dfe6ff"/>\
<rect x="10" y="1" width="1" height="1" fill="%23c7d2ff"/>\
<rect x="10" y="2" width="1" height="1" fill="%23b0c0ff"/>\
<rect x="2" y="3" width="6" height="1" fill="%23c9d4ff"/>\
<rect x="2" y="5" width="5" height="1" fill="%23c9d4ff"/>\
<rect x="2" y="7" width="6" height="1" fill="%23c9d4ff"/>\
</svg>');
}
#settingsPanel .title .chipBtn{ margin-left:10px; white-space:nowrap; }
@media (max-width:420px){ #settingsPanel .title .chipBtn{ margin-left:6px; } }

/* Overlay list spacing */
#changelogPanel .title{display:flex; align-items:center; justify-content:space-between;}
#changelogList{padding:6px 0 2px 2px;}
#changelogList ul{margin:6px 0 0 16px; padding:0;}
#changelogList li{margin:4px 0;}


/* v0.0.83: ensure Change Log overlay is hidden by default and sits on top */
#changelogOverlay{ display:none; position:fixed; inset:0; z-index:2100; align-items:center; justify-content:center; background:rgba(3,6,14,.65); backdrop-filter: blur(2px); }
</style>

<style>
/* 0.0.57 additions */
body.desktopMode #joystick { display:none !important; }
body.desktopMode { cursor: default; }
#settingsPanel .subtle { color:#9aa4d0; font-size:11px; }
.hud-editing .hudOutline { position:fixed; border:1px dashed #64e1ff; background:rgba(100,225,255,.05); pointer-events:auto; z-index:40; }
.hud-editing .hudHandle { position:absolute; width:10px; height:10px; right:-6px; bottom:-6px; border-radius:2px; background:#64e1ff; border:1px solid #0c1022; cursor: nwse-resize; }
.customHud #topbar, .customHud #inventory, .customHud #invPanel { position:fixed; }
.customHud #topbar { top:var(--topbar-y, 10px); left:var(--topbar-x, 10px); transform:scale(var(--topbar-scale,1)); transform-origin: top left; }
.customHud #inventory { bottom:auto; top:var(--inventory-y, calc(100vh - 60px)); left:var(--inventory-x, 10px); transform:scale(var(--inventory-scale,1)); transform-origin: top left; }
.customHud #invPanel { top:var(--invpanel-y, 80px); left:var(--invpanel-x, 20px); width:var(--invpanel-w, 360px); height:var(--invpanel-h, 300px); }
</style>

<style>
/* menu starfield fills viewport */
#menuStars{position:fixed; inset:0; display:block; background:#05060a; z-index:0; }
html, body { background:#05060a; height:100%; }
</style>
<style>
/* ===== 0.0.72 Pixel‑Art Main Menu Theme (non‑functional styling only) ===== */
:root{
  --px: 3px;
  --ink: #dfe6ff;
  --muted: #aab3d9;
  --panel-bg: #0b0f1f;
  --panel-hi: #2a356a;
  --panel-lo: #060a17;
  --panel-outline: #4b59d5;
  --btn-hi: #9cd8ff;
  --btn-lo: #234a6f;
  --accent: #5ee1ff;
}
html, body { background:#05060a; }

/* Crisper pixels on canvases and UI */
canvas, #menuStars { image-rendering: pixelated; image-rendering: crisp-edges; }

/* Title adjustments: centered and nudged upward a bit */
#menuWrap .title{
  text-align:center !important;
  transform: translateY(-10px);
  margin: 0 0 4px 0 !important;
  letter-spacing: 2px;
  text-shadow: 0 0 10px rgba(94,225,255,.2), 0 0 2px rgba(94,225,255,.5);
}
/* Slightly shift the whole menu upward so the title sits higher on screen */
#menuWrap{ top:46% !important; left:50% !important; transform:translate(-50%, -50%); }

/* Pixel panel chrome */
.panel{
  background:
    linear-gradient(#101425, #0e1328) padding-box,
    linear-gradient(180deg, rgba(94,225,255,.18), rgba(94,225,255,.04)) border-box;
  border: 2px solid transparent;
  box-shadow:
    inset 0 0 0 1px rgba(15, 22, 50, .8),
    0 0 0 1px rgba(30, 40, 90, .7),
    0 8px 24px rgba(0,0,0,.55);
}

/* Pixel buttons */
.btn, .btnL{
  position:relative;
  border:2px solid var(--panel-outline) !important;
  background:
    linear-gradient(180deg, rgba(50,90,160,.25), rgba(10,20,40,.6));
  color: var(--ink) !important;
  text-shadow: 0 1px 0 rgba(0,0,0,.6);
  box-shadow:
    inset -2px -2px 0 rgba(0,0,0,.35),
    inset  2px  2px 0 rgba(255,255,255,.05),
    0 0 0 2px rgba(12,16,34,.1);
}
.btn:hover, .btnL:hover{
  filter: brightness(1.08);
  transform: translateY(-1px);
}
.btn:active, .btnL:active{
  transform: translateY(0);
  box-shadow:
    inset  2px  2px 0 rgba(0,0,0,.4),
    inset -2px -2px 0 rgba(255,255,255,.04),
    0 0 0 2px rgba(12,16,34,.1);
}

/* Inputs keep readability but match the theme */
input[type="text"], input[type="range"]{
  border-radius: 8px !important;
  border: 2px solid rgba(118,198,255,.35) !important;
  background: rgba(10,14,30,.7) !important;
  color: var(--ink) !important;
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.6);
}

/* Small labels and meta text */
label, .muted{ color: var(--muted) !important; }

/* Mini info buttons in menu retain visibility over the starfield */
.infoMini{
  background: linear-gradient(180deg, rgba(80,120,200,.4), rgba(30,50,100,.7)) !important;
  border-color: var(--panel-outline) !important;
}

/* Subtle scanline/CRT overlay only over the start screen area */
#startOverlay::after{
  content:"";
  position:absolute; inset:0;
  pointer-events:none;
  background:
    repeating-linear-gradient(to bottom,
      rgba(255,255,255,.05), rgba(255,255,255,.05) 2px,
      transparent 2px, transparent 4px);
  mix-blend-mode: overlay;
  opacity:.06;
}
</style>

<style>
/* 0.0.57 UI polish */
#settingsOverlay{z-index:2000; backdrop-filter: blur(6px); background: rgba(6,10,22,0.55);}
#settingsPanel{max-width: min(720px, 92vw); width: min(720px, 92vw); border-radius: 16px; background: rgba(18,24,46,.94); box-shadow: 0 10px 32px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.06); border: 1px solid rgba(100,120,200,.22);}
#settingsPanel .title{font-weight:700; letter-spacing:.02em; color:#dfe6ff;}
#settingsPanel .muted{color:#aab3d9;}
#settingsPanel .row{display:flex; align-items:center; justify-content:space-between; gap:12px; padding:6px 0;}
#settingsPanel .row > label:first-child{min-width:160px;}
#settingsPanel hr{border:none; height:1px; background:linear-gradient(90deg,transparent,#1d254a,transparent); margin:10px -12px;}
/* segmented control for mode */
.segCtl{display:inline-flex; border:1px solid rgba(120,140,220,.35); border-radius:12px; overflow:hidden; background:rgba(10,14,30,.6);}
.segCtl input{display:none;}
.segCtl label{padding:6px 12px; cursor:pointer; user-select:none; color:#aab3d9;}
.segCtl input:checked + label{background:#1a2758; color:#e8f0ff;}
/* select + slider polish */
#settingsPanel select{background:#0f1736; color:#e9efff; border:1px solid rgba(120,140,220,.35); border-radius:8px; padding:6px 10px;}
#settingsPanel input[type=range]{width:100%;}
#settingsPanel .subtle{color:#9aa4d0; font-size:11px;}
/* Buttons */
#settingsPanel .btnL{background:#0f1736; color:#e9efff; border:1px solid rgba(120,140,220,.35); border-radius:10px; padding:6px 10px;}
#settingsPanel .btnL:hover{filter:brightness(1.1);}
/* Desktop toggles */
</style>

<style>
/* 0.0.57 Settings polish v2 */
#settingsOverlay{z-index:2000; backdrop-filter: blur(8px); background: rgba(6,10,22,0.55);}
#settingsPanel{max-width:min(760px,94vw); width:min(760px,94vw); max-height:88vh; overflow:auto;
  border-radius:18px; background:rgba(16,22,44,.94);
  box-shadow:0 12px 36px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.06);
  border:1px solid rgba(120,140,220,.28); padding:16px 16px 14px;
}
#settingsPanel h2{font-size:28px; margin:4px 0 12px; letter-spacing:.02em; color:#e5ecff;
  text-shadow:0 0 16px rgba(120,180,255,.25), 0 2px 0 rgba(0,0,0,.4);
}
#settingsPanel .row{display:flex; align-items:center; gap:12px; padding:6px 0;}
#settingsPanel .row > label:first-child{min-width:160px; color:#aab3d9;}
#settingsPanel .right{margin-left:auto;}
#settingsPanel hr{border:none; height:1px; background:linear-gradient(90deg,transparent,#1d254a,transparent); margin:10px -12px;}
.segCtl{display:inline-flex; border:1px solid rgba(120,140,220,.35); border-radius:12px; overflow:hidden; background:rgba(10,14,30,.6);}
.segCtl input{display:none;}
.segCtl label{padding:6px 12px; cursor:pointer; user-select:none; color:#aab3d9;}
.segCtl input:checked + label{background:#1a2758; color:#e8f0ff;}
#settingsPanel select{background:#0f1736; color:#e9efff; border:1px solid rgba(120,140,220,.35); border-radius:8px; padding:6px 10px;}
#settingsPanel .subtle{color:#9aa4d0; font-size:11px;}
</style>

<style>
/* 0.0.57 tweaks */
#settingsPanel input[type=radio]{ transform: scale(1.25); }
.segCtl label{ padding: 8px 14px; font-size:14px; }
</style>

<style>
/* 0.0.57: stronger joystick hide and larger desktop radio */

#settingsPanel input[type=radio]{ transform: scale(1.35); }
</style>

<style>
/* 0.0.57 menu settings button visibility */
#menuWrap .btnL#menuSettingsBtn{ display:inline-block; }
</style>

<style>
/* 0.0.57: larger desktop/mobile radios */
#settingsPanel input[type=radio]{ transform: scale(1.35); }
</style>

<style id="healthbar-cleaned">
#healthBar{ gap:3px; padding:2px 6px; border-radius:10px; border:1px solid rgba(45,53,98,.9);
  background: rgba(8,12,28,.18); box-shadow: inset 0 0 0 1px rgba(12,16,34,.9), 0 1px 4px rgba(0,0,0,.3);
  max-width: min(42vw, 220px); display:inline-flex; align-items:center; }
#healthBar .seg{ width:14px; height:8px; border-radius:3px; background:
  linear-gradient(180deg, #1a214f, #0a0f2a);
  box-shadow: inset 0 0 0 1px #0a0f2a, 0 1px 0 rgba(255,255,255,.05); }
#healthBar .seg.filled{ background:
  linear-gradient(180deg, #ffb6ad, #ff6a5f);
  box-shadow: inset 0 0 0 1px #6b1221, 0 0 6px rgba(255,80,80,.25); }
</style>

<style id="sys-dd-style">
  /* v0.0.82: System Objects dropdown */
  #sysObjectsWrap { display:flex; gap:6px; align-items:center; margin-top:4px; pointer-events:auto; }
  #sysObjectsWrap[hidden] { display:none; }
  #sysObjectsDD { background:#2a0b46; color:#efe5ff; border:1px solid #4e2b6d; border-radius:8px; padding:4px 8px; font-size:12px; }
  #sysObjectsDD summary { list-style:none; cursor:pointer; }
  #sysObjectsDD[open] summary { opacity:0.95; }
  #sysObjectsList { margin:6px 0 0 0; padding:0; max-height:180px; overflow:auto; font-size:12px; color:#efe5ff; min-width:180px; }
  #sysObjectsList li { list-style:none; margin:0; padding:4px 6px; cursor:pointer; border-radius:6px; }
  #sysObjectsList li:hover { background:#3a1460; }
  #sysObjectsList li.moon { padding-left:16px; opacity:0.95; }
  #sysGoBtn { display:none; background:#45196b; color:#efe5ff; border:1px solid #5d2c87; border-radius:8px; padding:6px 10px; font-size:12px; cursor:pointer; }
  #sysGoBtn:hover { filter:brightness(1.1); }
  /* Ensure it sits under the black info pill (#topLeft contents) */
  #topLeft > #sysObjectsWrap { align-self:stretch; }
</style>

</head>
<body class="menuOpen">
  <canvas class="bg" id="menuStars"></canvas>
  <section id="startOverlay" aria-modal="true" role="dialog">
    
    <div id="menuWrap">
      <div class="title">Space Bitz <span class="ver" id="menuVer"></span></div>
      <div class="panel">
        <div class="row" style="margin-top:8px; align-items:center;">
          <label class="muted" for="densitySlider" style="margin-right:8px;">Star density</label>
          <input id="densitySlider" type="range" min="1" max="100" value="100" step="1" style="flex:1">
          <div id="densityVal" class="muted" style="width:42px; text-align:right;">100%</div>
        </div>

        <div class="grid2">
          <div class="field">
            <label for="universeName">Universe Name</label>
            <input type="text" id="universeName" placeholder="My Universe" maxlength="40">
          </div>
          <div class="field">
            <label for="seed">Seed</label>
            <input type="text" id="seed" placeholder="random if blank" maxlength="64">
          </div>
        </div>
        <div class="row">

<button class="btnL" id="menuSettingsBtn">Settings</button>
<button class="btnL" id="randSeed">Randomize Seed</button>
          <div style="flex:1"></div>
          <button class="btnL" id="createStart">Create & Start</button>
        </div>
        
        <div class="muted">Options</div>
        <div class="row"><label class="muted" for="cheatsToggle">Cheats</label><input id="cheatsToggle" type="checkbox"></div>
<div class="row"><label class="muted" for="startOnEarthToggle">Start on Earth</label><input id="startOnEarthToggle" type="checkbox"></div>

        <div style="height:6px"></div>
<div class="muted">Saved Universes</div>
        <div class="saves" id="savesList"></div>
      </div>
    </div>
  </section>

  <!-- Canvas -->
  <canvas id="game" width="320" height="180" aria-label="Space Bitz Game"></canvas>
  <!-- Floating Info Buttons (system level) -->
  <button id="infoBtnStar" class="btn infoMini" aria-label="Star Info">Info</button>
  <button id="infoBtnBody" class="btn infoMini" aria-label="Body Info">Info</button>

  <!-- Info Overlay -->
  <section id="infoOverlay" role="dialog" aria-modal="true">
    <div id="infoPanel">
      <div id="infoTitle" class="title" style="font-size:20px; letter-spacing:1px; margin:0 0 8px 0;">Info</div>
      <div id="infoDetails" class="muted" style="margin-bottom:10px;">—</div>
      <div class="row"><button id="closeInfo" class="btnL">Close</button></div>
    </div>
  </section>

  <!-- Topbar -->
  <section id="topbar">
    <div id="topLeft">
      <div id="locLabel">—</div>
      <div id="coords">X: 0  Y: 0  Z: 0</div>
      <div id="fps" class="muted" style="font-size:11px;">FPS: 0</div>
      <div id="debugRow" class="muted" style="font-size:11px; display:none;">—</div>
    </div>
    <div id="healthWrap">
      <div id="heartWrap" aria-hidden="true">
        <svg viewBox="0 0 32 32"><path fill="#ff5a5f" d="M23.6 3.8c-2.6 0-4.9 1.5-7.6 4.6-2.7-3.1-5-4.6-7.6-4.6C4.6 3.8 2 6.4 2 9.8c0 5.7 5.8 9.7 14 18.4 8.2-8.7 14-12.7 14-18.4 0-3.4-2.6-6-6.4-6z"/></svg>
      </div>
      <div id="healthBar" role="meter" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100"></div>
    </div>
  
  <div id="commandPane" class="pill" style="position:absolute; display:none; z-index:1000; pointer-events:auto; padding:6px 10px; background: rgba(60,30,110,0.35); border:1px solid rgba(120,80,200,0.55); border-radius:14px;">
    <div id="cmdInner" style="display:flex; align-items:center; gap:8px; width:100%;">
      <span aria-hidden="true" style="color:#fff; font:12px ui-monospace;">›</span>
      <input id="cmdInput" type="text" autocomplete="off" spellcheck="false"
             style="flex:1; min-width:0; background:rgba(0,0,0,0.25); border:1px solid rgba(120,80,200,0.35); border-radius:10px; outline:none; color:#fff; caret-color:#fff; font:12px ui-monospace; letter-spacing:.2px; padding:6px 10px;"
             placeholder="type a command… e.g. /tel -3, 4">
    </div>
      <button id="cmdExecBtn" class="btn" style="display:none; margin-top:6px; align-self:flex-end; background:rgba(120,80,200,0.25); border:1px solid rgba(120,80,200,0.6); color:#fff; border-radius:10px; padding:6px 12px;; pointer-events:auto; pointer-events:auto" type="button" onclick="window.execCmd()">Execute</button>
  </div>
</section>

  <!-- Anim layer (for launch/landing) -->
  <div id="animLayer"><canvas id="animCanvas"></canvas></div>

  <!-- Joystick -->
  <div id="joystick"><div id="stick"></div></div>

  <!-- Settings Overlay -->
  <section id="settingsOverlay" style="display:none; position:fixed; inset:0; z-index:2000; align-items:center; justify-content:center;">
    <div id="settingsPanel" class="panel" style="min-width:280px; max-width:90vw;">
      <div class="title" style="margin-bottom:8px; display:flex; align-items:center;">Settings <span id="settingsVer" style="margin-left:auto; font-weight:500; color:#aab3d9;; font-size:0.25em"></span></div>
      <div class="row"><label class="muted" for="musicToggle">Music</label><input id="musicToggle" type="checkbox"></div>
      <div class="row"><label class="muted">SFX</label><input type="checkbox" disabled></div>
      <div class="row"><label class="muted">Reduce Motion</label><input type="checkbox" disabled></div>
      <div class="row" style="gap:10px; align-items:center;"><label class="muted" style="min-width:110px;">Joystick X</label><input id="joyX" type="range" min="0" max="100" value="50" style="flex:1"><div id="joyXVal" class="muted" style="width:48px;text-align:right;">50%</div></div>
      <div class="row" style="gap:10px; align-items:center;"><label class="muted" style="min-width:110px;">Joystick Y</label><input id="joyY" type="range" min="0" max="200" value="125" style="flex:1"><div id="joyYVal" class="muted" style="width:48px;text-align:right;">125px</div></div>
      
      <div class="row" style="gap:10px; align-items:center;">
        <label class="muted" for="unitsSelect" style="min-width:110px;">Units</label>
        <select id="unitsSelect" class="btnL" style="min-width:140px;">
          <option value="mi">Miles</option>
          <option value="km">Kilometers</option>
        </select>
      </div>
      <div class="row"><label class="muted" for="showCoords">Show Coordinates</label><input id="showCoords" type="checkbox" checked></div>
      <div class="row"><label class="muted" for="showFPS">Show FPS</label><input id="showFPS" type="checkbox" checked></div>
      <div class="row"><label class="muted" for="showTravelLines">Show Travel Lines</label><input id="showTravelLines" type="checkbox"></div>
      <div class="row"><button id="openCheatsMenu" class="btnL" style="display:none;">Cheats Menu</button></div>
      <div id="cheatsPanelLegacy" style="display:none; margin-top:8px; padding-top:6px; border-top:1px dashed rgba(255,255,255,0.03);">
        <div class="muted">Cheats</div>
        <div class="row"><label class="muted" for="teleportToggle_old">Command Line</label><input id="teleportToggle_old" type="checkbox"></div>
      </div>

      <div class="row" style="gap:10px; align-items:center;">
        <label class="muted" for="timeModeSelect" style="min-width:110px;">Clock Mode</label>
        <select id="timeModeSelect" class="btnL" style="min-width:140px;">
          <option value="local">Local Time</option>
          <option value="real">Real (UTC)</option>
        </select>
      </div>
    <div class="row" style="display:flex; gap:10px; justify-content:flex-end;"><button id="saveQuitBtn" class="btnL btnDangerOutline">Save &amp; Quit</button><button id="closeSettings" class="btnL btnDangerOutline">Close</button></div>
    </div>
  </section>
  <!-- Cheats Menu Overlay -->
  <section id="cheatsMenuOverlay" style="display:none; position:fixed; inset:0; z-index:2100; align-items:center; justify-content:center; background:rgba(3,6,14,.65); backdrop-filter: blur(2px);">
    <div class="panel" style="min-width:280px; max-width:90vw;">
      <div class="title" style="margin-bottom:8px;">Cheats Menu</div>
      <div class="muted" style="margin-bottom:6px;">Developer options (when Cheats are enabled)</div>
      <div class="row"><label class="muted" for="teleportToggle" style="min-width:160px;">Show Command Line</label><input id="teleportToggle" type="checkbox"></div>
      <div class="row"><label class="muted" for="showDebugLine" style="min-width:160px;">Show Debug Line</label><input id="showDebugLine" type="checkbox"></div>
      <div class="row" style="justify-content:flex-end;"><button id="closeCheatsMenu" class="btnL">Close</button></div>
    </div>
  </section>

  <!-- Expanded Inventory -->
  <section id="invOverlay">
    <div id="invPanel">
      <div id="invGrid"></div>
      <div style="display:flex;justify-content:flex-end;margin-top:10px;">
        <button class="btnL" id="closeInv">Close</button>
      </div>
    </div>
  </section>

  <!-- HUD -->
  <section id="hud">
    <div id="actionsRow">
      <div class="leftActions">
        <button id="actionMain" class="btn">Interact</button>
        <button id="renameBtn" class="btn" style="display:none;">Rename</button>
      </div>
      <div class="rightActions">
        <button id="warpBtn" class="btn" style="display:none;">Warp Drive</button>
        <button id="enterBtn" class="btn" style="display:none;">Enter Star System</button>
      </div>
    </div>
    <div id="inventory" aria-label="Inventory HUD">
      <div class="slot"><span>Empty</span></div>
      <div class="slot"><span>Empty</span></div>
      <div class="slot"><span>Empty</span></div>
      <div class="slot"><span>Empty</span></div>
      <div class="slot"><span>Empty</span></div>
      <div class="slot more" id="moreInv">⋯</div><button id="settingsBtn" class="btn" title="Settings" aria-label="Settings">⚙️</button>
    </div>
  </section>

  <div id="toast" role="status" aria-live="polite">Hello, Captain.</div>
<script>
(() => {
  'use strict';

  let DPR = 1;

  // Updated version after applying bug fixes.
  // Bump to 0.0.95 after addressing travel‑line and UI bugs
  const VERSION = "0.0.95";

  window.VERSION = VERSION;

/* === v0.0.44 additions: settings + fps + input fix === */
const SETTINGS_KEY = 'spacebitz:settings2';
let SETTINGS = null;
function _loadSettings(){ try { return JSON.parse(localStorage.getItem(SETTINGS_KEY) || '{}'); } catch(e){ return {}; } }
function _saveSettings(s){ try { localStorage.setItem(SETTINGS_KEY, JSON.stringify(s)); } catch(e){} }
function _withDefaults(s){ return { showCoords: (s.showCoords!==false), showFPS: (s.showFPS!==false) , showDebugLine: !!s.showDebugLine , showTravelLines: !!s.showTravelLines }; }
function applySettings(){
  try {
    const s = SETTINGS || _withDefaults({});
    const coordsEl = document.getElementById('coords');
    const fpsEl = document.getElementById('fps');
    if (coordsEl) { coordsEl.style.display = s.showCoords ? '' : 'none'; }
    if (fpsEl) { fpsEl.style.display = s.showFPS ? '' : 'none'; }
    const dbgEl = document.getElementById('debugRow'); if (dbgEl) { dbgEl.style.display = (s.cheatsEnabled && s.showDebugLine) ? '' : 'none'; }
    const cheatBtn = document.getElementById('openCheatsMenu'); if (cheatBtn) cheatBtn.style.display = s.cheatsEnabled ? '' : 'none';
    const debugToggle = document.getElementById('showDebugLine'); if (debugToggle) debugToggle.checked = !!s.showDebugLine;
    const travelToggle = document.getElementById('showTravelLines'); if (travelToggle) travelToggle.checked = !!s.showTravelLines;
    const sc = document.getElementById('showCoords'); if (sc) sc.checked = !!s.showCoords;
    const sf = document.getElementById('showFPS'); if (sf) sf.checked = !!s.showFPS;
    // Cheats panel + settings wiring
    const cheatsPanel = document.getElementById('cheatsPanelLegacy'); if (cheatsPanel) cheatsPanel.style.display = 'none';
    const cheatsToggle = document.getElementById('cheatsToggle'); if (cheatsToggle) cheatsToggle.checked = !!s.cheatsEnabled;
    const teleToggle = document.getElementById('teleportToggle'); if (teleToggle) teleToggle.checked = !!s.teleportEnabled;
    // Teleport pane visibility (if in hyperspace and cheats/teleport enabled)
    try{ updateCommandPaneVisibility(); }catch(e){}
  } catch(e){}
}
SETTINGS = _withDefaults(_loadSettings());
// Ensure new defaults
// Enable cheats and teleport by default for testing
if (typeof SETTINGS.cheatsEnabled === 'undefined') SETTINGS.cheatsEnabled = false;
if (typeof SETTINGS.teleportEnabled === 'undefined') SETTINGS.teleportEnabled = false;
if (typeof SETTINGS.showCoords === 'undefined') SETTINGS.showCoords = true;
if (typeof SETTINGS.showFPS === 'undefined') SETTINGS.showFPS = true;
if (typeof SETTINGS.showDebugLine === 'undefined') SETTINGS.showDebugLine = false;
if (typeof SETTINGS.showTravelLines === 'undefined') SETTINGS.showTravelLines = false;
document.addEventListener('DOMContentLoaded', applySettings);
document.addEventListener('change', (e)=>{
  if (!(e && e.target)) return;
  if (e.target.id === 'showTravelLines'){ SETTINGS.showTravelLines = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); }
}, true);

document.addEventListener('change', (e)=>{
  if (!(e && e.target)) return;
  if (e.target.id === 'showCoords'){ SETTINGS.showCoords = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); }
  if (e.target.id === 'showFPS'){ SETTINGS.showFPS = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); }
  if (e.target.id === 'cheatsToggle'){ SETTINGS.cheatsEnabled = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); }
  if (e.target.id === 'teleportToggle'){ SETTINGS.teleportEnabled = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); }
});

// Teleport pane logic (cheats)
function updateCommandPaneVisibility(){
  try{
    const pane = document.getElementById('commandPane');
    const topLeft = document.getElementById('topLeft');
    if(!pane) return;
    const enabled = !!(SETTINGS && SETTINGS.cheatsEnabled && SETTINGS.teleportEnabled);
    const isHyper = (typeof game !== 'undefined' && game.state === STATE.HYPER);
    if (enabled && isHyper){
      // position directly beneath top-left HUD
      if (topLeft){ const rect = topLeft.getBoundingClientRect(); pane.style.left = (rect.left + 6) + 'px'; pane.style.top = (rect.bottom + 6) + 'px'; }
      pane.style.display = '';
      try{ var exec=document.getElementById('cmdExecBtn'); if(exec) exec.style.display=''; }catch(e){}
    } else { pane.style.display = 'none'; }
  }catch(e){}
}

document.addEventListener('click', function(e){
  if(!e || !e.target) return;
  
});

// Also update teleport pane visibility each second to pick up state changes
setInterval(function(){ try{ updateCommandPaneVisibility(); }catch(e){} }, 800);
// Lightweight FPS counter (independent of game loop)

// Ensure direct listeners for settings checkboxes so toggles reliably apply immediately
document.addEventListener('DOMContentLoaded', function(){
  try{
    const sc = document.getElementById('showCoords');
    const sf = document.getElementById('showFPS');
    const cheatsToggle = document.getElementById('cheatsToggle');
    const teleToggle = document.getElementById('teleportToggle');
    if (sc) sc.addEventListener('change', function(e){ SETTINGS.showCoords = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); });
    if (sf) sf.addEventListener('change', function(e){ SETTINGS.showFPS = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); });
    if (cheatsToggle) cheatsToggle.addEventListener('change', function(e){ SETTINGS.cheatsEnabled = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); });
    if (teleToggle) teleToggle.addEventListener('change', function(e){ SETTINGS.teleportEnabled = !!e.target.checked; _saveSettings(SETTINGS);
    const travelToggle = document.getElementById('showTravelLines'); if (travelToggle) travelToggle.addEventListener('change', function(e){ SETTINGS.showTravelLines = !!e.target.checked; _saveSettings(SETTINGS); applySettings(); }); applySettings(); });
  }catch(e){}
});
// Also ensure startFPSCounter respects SETTINGS each tick and updateCoordsUI enforces coords display
(function startFPSCounter(){
  let lastUpdate = performance.now();
  let frames = 0;
  function loop(now){
    game._now = now; frames++;
    if (now - lastUpdate >= 500){
      const fps = Math.round(frames * 1000 / (now - lastUpdate));
      lastUpdate = now;
      frames = 0;
      const el = document.getElementById('fps');
      if (el) {
        el.textContent = 'FPS: ' + fps;
        if (typeof SETTINGS !== 'undefined') el.style.display = SETTINGS.showFPS ? '' : 'none';
      }
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

// Cheats-only debug row updater: shows state, followSelectionId, galaxy target
(function startDebugRow(){
  function loop(){
    try {
      var dbg = document.getElementById('debugRow');
      if (dbg && typeof SETTINGS !== 'undefined' && SETTINGS.cheatsEnabled){
        var st = (window.game && game.state) ? game.state : '—';
        var follow = (game && game.followSelectionId!=null) ? String(game.followSelectionId) : '—';
        var tgt = (game && game.galaxy && game.galaxy.target) ? (game.galaxy.target.name || game.galaxy.target.id || 'target') : '—';
        dbg.textContent = "state=" + st + "  follow=" + follow + "  target=" + tgt;
      }
    } catch(e){};
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();

})();

// Cheats Menu overlay wiring
(function(){
  try {
    var btn = document.getElementById('openCheatsMenu');
    var ov = document.getElementById('cheatsMenuOverlay');
    var closeBtn = document.getElementById('closeCheatsMenu');
    function open(){ if (ov){ ov.style.display = 'flex'; try{ applySettings(); }catch(e){} } }
    function close(){ if (ov){ ov.style.display = 'none'; } }
    if (btn) btn.addEventListener('click', open);
    if (closeBtn) closeBtn.addEventListener('click', close);
    if (ov) ov.addEventListener('click', function(e){ if (e.target===ov) close(); });
  } catch(e){}
})();

// Add listener for debug line toggle
(function(){
  try {
    var debugToggle = document.getElementById('showDebugLine');
    if (debugToggle) debugToggle.addEventListener('change', function(e){
      SETTINGS.showDebugLine = !!e.target.checked;
      try { _saveSettings(SETTINGS); } catch(_){}
      try { applySettings(); } catch(_){}
    });
  } catch(e){}
})();

// Unified command executor for the command line
window.execCmd = function(){
  try{
    var i = document.getElementById('cmdInput');
    if(!i) return;
    var t = (i.value||'').trim();
    if (!t) return;
    // /tel x, y  OR  /tel <name>
    var m = /^\s*\/tel\s+(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/.exec(t);
    if (m){
      var x = Number(m[1]), y = Number(m[2]);
      if (window.game && game.state===STATE.HYPER && game.galaxy && game.galaxy.ship){
        game.galaxy.target = null; game.galaxy.freeTarget = null;
        game.galaxy.ship.vx = 0; game.galaxy.ship.vy = 0;
        // Convert sector coords (UI) to internal units (×10) to match on-screen coords and travel logic.
        game.galaxy.ship.x = x * 10; game.galaxy.ship.y = y * 10;
        try{ if(typeof toast==='function') toast('Teleported to '+x+', '+y); }catch(_){}
      }
      return;
    }
    var m2 = /^\s*\/tel\s+(.+?)\s*$/.exec(t);
    if (m2){
      if (window.game && game.state===STATE.HYPER && game.galaxy){
        var name = m2[1];
        var ss = findStarByName(game.galaxy, name);
        if (ss){
          game.galaxy.target = null; game.galaxy.freeTarget = null;
          game.galaxy.ship.vx = 0; game.galaxy.ship.vy = 0;
          game.galaxy.ship.x = ss.x; game.galaxy.ship.y = ss.y;
          // record visit
          try { if (!game.galaxy.visited) game.galaxy.visited = []; var last = game.galaxy.visited[game.galaxy.visited.length-1]; if (last !== ss.id && game.galaxy.visited.indexOf(ss.id) === -1) game.galaxy.visited.push(ss.id); } catch(e){}
          try{ if(typeof toast==='function') toast('Teleported to '+ computeStarNameForSystem(ss.seed)); }catch(_){}
        } else {
          try{ if(typeof toast==='function') toast('Star not found: '+name); }catch(_){}
        }
      }
      return;
    }
  }catch(e){}
};
// Fix: allow typing WASD in inputs / when menu is open
window.addEventListener('keydown', function(e){
  try {
    const t = e.target;
    const tag = (t && t.tagName || '').toLowerCase();
    const inField = tag === 'input' || tag === 'textarea' || (t && t.isContentEditable);
    const menuOpen = document.body.classList.contains('menuOpen');
    if (inField || menuOpen){
      const k = e.key;
      if (k==='a'||k==='A'||k==='s'||k==='S'||k==='w'||k==='W'||k==='d'||k==='D'){
        // Let inputs receive the character. Stop game handlers from stealing it.
        if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
        e.stopPropagation();
        return;
      }
    }
  } catch(_){}
}, true);

function escapeHTML(s){ return (""+s).replace(/[&<>"\']/g, c=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","\'":"&#39;" }[c])); }

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  ctx.imageSmoothingEnabled = false;

  const menuStars = document.getElementById('menuStars');
  const msCtx = menuStars.getContext('2d', { alpha: false });

  const animCanvas = document.getElementById('animCanvas');
  const actx = animCanvas.getContext('2d', { alpha: true });
  function fitAnim(){
    animCanvas.style.width = VIEW_W + 'px';
    animCanvas.style.height = VIEW_H + 'px';
    animCanvas.width = canvas.width;
    animCanvas.height = canvas.height;
    actx.setTransform(DPR, 0, 0, DPR, 0, 0);
    actx.imageSmoothingEnabled = false;
  }
  actx.imageSmoothingEnabled = false;

  let VIEW_W = 320, VIEW_H = 180;
  function fitCanvas() {
    const hudH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--hud-h'));
    VIEW_W = Math.floor(window.innerWidth);
    VIEW_H = Math.max(200, Math.floor(window.innerHeight) + 2);
    DPR = Math.min(2, window.devicePixelRatio || 1);
    canvas.style.width = VIEW_W + 'px';
    canvas.style.height = VIEW_H + 'px';
    canvas.width  = Math.floor(VIEW_W * DPR);
    canvas.height = Math.floor(VIEW_H * DPR);
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    ctx.imageSmoothingEnabled = false;
    fitAnim();
    fitMenuStars();
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  /* ---- Start menu starfield ---- */
  window.menuStarsActive = true;
  let stars = [];
  function fitMenuStars(){ menuStars.width = window.innerWidth; menuStars.height = window.innerHeight; }
  function initStars(){
    stars = [];
    for(let i=0;i<260;i++){
      const sp = (Math.random()<0.85?1:2);
      stars.push({ x:(Math.random()*2-1), y:(Math.random()*2-1), z: Math.random()*1.0 + 0.2, s: sp,
        twPhase: Math.random()*Math.PI*2, twSpeed: (sp===2?1.6:1.1)*(0.0015 + Math.random()*0.0015) });
    }
  }
  function drawMenuStars(dt){ if (!window.menuStarsActive) { return; } dt = Math.min(dt||16, 34);
    const w = menuStars.width, h = menuStars.height;
    msCtx.fillStyle = '#03040a'; msCtx.fillRect(0,0,w,h);
    stars.forEach(s => {
      s.z -= dt*0.00025; if (s.z < 0.05){ s.x=(Math.random()*2-1); s.y=(Math.random()*2-1); s.z=1; }
      const px = (s.x / s.z) * 0.5 * w + w/2;
      const py = (s.y / s.z) * 0.5 * h + h/2;
      if (px<-4||px>w+4||py<-4||py>h+4) return;
      if (typeof s.twPhase==='number'){ s.twPhase += s.twSpeed * dt; msCtx.globalAlpha = 0.65 + 0.35*Math.sin(s.twPhase); } msCtx.fillStyle = (s.s===2?'#def3ff':'#bcd7ff'); msCtx.fillRect(px|0, py|0, s.s, s.s); msCtx.globalAlpha = 1;
    });
    requestAnimationFrame((t)=>{ if(!window.menuStarsActive) return; const now = t || performance.now(); const last = (drawMenuStars._last||now); const dt = Math.min(now - last, 34); drawMenuStars(dt); drawMenuStars._last = now; });
  }
  
  document.addEventListener('visibilitychange', ()=>{ if (!document.hidden) { drawMenuStars._last = performance.now(); } });
initStars(); drawMenuStars(16);

  function mulberry32(a) { return function(){ var t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  function seededRandom(seed) { if (typeof seed === 'string') { let h=2166136261>>>0; for (let i=0;i<seed.length;i++){ h^=seed.charCodeAt(i); h=Math.imul(h,16777619);} return mulberry32(h>>>0); } return mulberry32(seed>>>0); }
  function randomSeed() { try { const b=new Uint32Array(1); crypto.getRandomValues(b); return b[0].toString(16); } catch(e){ return Math.floor(Math.random()*0xffffffff).toString(16);} }

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  function toast(msg, ms=1600) { const el = document.getElementById('toast'); el.textContent = msg; el.classList.add('show'); clearTimeout(toast._t); toast._t = setTimeout(() => el.classList.remove('show'), ms); }

  /* Names */
  const NAME_KEY = 'spacebitz:names';
  let NAMES_CACHE = null;
  function _rawLoadNames(){ try { return JSON.parse(localStorage.getItem(NAME_KEY) || '{}'); } catch(e){ return {}; } }
  function loadNames(){ if (NAMES_CACHE===null) NAMES_CACHE = _rawLoadNames(); return NAMES_CACHE; }
  function saveNames(map){ NAMES_CACHE = map; localStorage.setItem(NAME_KEY, JSON.stringify(map)); }
  function getNameOr(seed, fallback){ const map = loadNames(); return map[seed] || fallback; }
  function setCustomName(seed, name){ const map = loadNames(); map[seed]=name; saveNames(map); }
  
  /* Saves */
  const STORAGE_KEY = 'spacebitz:saves';
  function loadSaves(){ try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]'); } catch(e){ return []; } }
  function saveSaves(list){ localStorage.setItem(STORAGE_KEY, JSON.stringify(list)); }
  function addSave(u){ const list = loadSaves(); list.push(u); saveSaves(list); return list; }
  function deleteSave(id){ const list = loadSaves().filter(s=>s.id!==id); saveSaves(list); return list; }

  // Unified star/System naming (top-level)
  function computeStarNameForSystem(systemSeed){
    const r = seededRandom('sys:'+systemSeed);
    const fallback = window.uniqueNameFor('sys:'+systemSeed+':star', r);
    const starSeed = systemSeed + ':star';
    return getNameOr(starSeed, getNameOr(systemSeed, fallback));
  }

  // v0.0.74 helpers: derive star color from system seed + hex->rgba
  function computeStarColorForSeed(systemSeed){
    try{
      const r = seededRandom('sys:'+systemSeed);
      const starTypes = [
        {type:'M', color:'#ff6a4b', r: 14},
        {type:'G', color:'#ffd26a', r: 16},
        {type:'B', color:'#9ad1ff', r: 18},
        {type:'K', color:'#ffb665', r: 15},
        {type:'A', color:'#fff8f0', r: 13}
      ];
      return starTypes[(r()*starTypes.length)|0].color;
    }catch(e){ return '#e8f2ff'; }
  }
  function rgbaFromHex(hex, a){
    try{
      const h = hex.replace('#','').trim();
      const r = parseInt(h.substring(0,2),16);
      const g = parseInt(h.substring(2,4),16);
      const b = parseInt(h.substring(4,6),16);
      return 'rgba('+r+','+g+','+b+','+(a==null?1:a)+')';
    }catch(e){ return 'rgba(200,220,255,'+(a==null?1:a)+')'; }
  }

  /* Health UI */
  const healthBar = document.getElementById('healthBar');
  for (let i=0;i<15;i++){ const seg=document.createElement('div'); seg.className='seg'; healthBar.appendChild(seg); }
  function setHealthUI(val){ const v=clamp(val,0,100); const filled = Math.round(v/6.6667); [...healthBar.children].forEach((c,i)=>{ c.classList.toggle('filled', i < filled); }); healthBar.setAttribute('aria-valuenow', v); }

  function makeCanvas(w,h,dpr=1){ const c=document.createElement('canvas'); c.width=w*dpr; c.height=h*dpr; const cx=c.getContext('2d',{alpha:true}); cx.imageSmoothingEnabled=false; cx.scale(dpr,dpr); return [c,cx]; }
  function makePlayerSprite(){
    const [c, cx] = makeCanvas(16*3, 20*4);
    function frame(x,y,dir,step){
      const skin = '#ffd7b1', suit='#64a4ff', hair='#3b2a18', visor='#9ad7ff', boots='#263a6a';
      cx.save(); cx.translate(x,y); const flip=(dir==='left'); if(flip){ cx.translate(16,0); cx.scale(-1,1); }
      const la=(step===0?1:step===1?0:2), lb=2-la;
      cx.fillStyle='rgba(0,0,0,0.25)'; cx.fillRect(4,18,8,2);
      cx.fillStyle=boots; cx.fillRect(4,16+(dir==='down'?0:1),3,3); cx.fillRect(9,16+(dir==='down'?1:0),3,3);
      cx.fillStyle=suit; cx.fillRect(4,12+la*0.3,3,4); cx.fillRect(9,12+lb*0.3,3,4);
      cx.fillRect(4,7,8,6); cx.fillRect(2,8+(step===1?1:0),2,4); cx.fillRect(12,8+(step===1?0:1),2,4);
      cx.fillStyle=hair; cx.fillRect(4,0,8,3); cx.fillStyle=skin; cx.fillRect(4,3,8,4);
      if(dir==='up'){ cx.fillStyle=hair; cx.fillRect(4,2,8,1); } else { cx.fillStyle=visor; cx.fillRect(6,4,6,2); cx.fillStyle='#74bfff'; cx.fillRect(6,4,2,2); }
      cx.restore();
    }
    ['down','up','right','left'].forEach((d,row)=>{ for(let s=0;s<3;s++) frame(16*s, 20*row, d, s); });
    return c;
  }
  function makeShipSprite(){ const [c,cx]=makeCanvas(24,14); cx.fillStyle='#dbe9ff'; cx.fillRect(0,0,24,14); cx.clearRect(0,0,24,14);
    cx.fillStyle='#b6c6e6'; cx.fillRect(2,4,20,6); cx.fillStyle='#7fa0ff'; cx.fillRect(10,2,4,10); cx.fillStyle='#e8f1ff'; cx.fillRect(4,5,16,4);
    cx.fillStyle='#8ed3ff'; cx.fillRect(7,4,10,3); cx.fillStyle='#94a4cc'; cx.fillRect(0,5,2,4); cx.fillRect(22,5,2,4); return c; }
  const playerSprite = makePlayerSprite();
  const shipSprite = makeShipSprite();
  const SHIP_W = 24;

  const STATE = { GROUND:'ground', SPACE:'space', HYPER:'hyper' };
  let game = {
    universe:null, state:STATE.GROUND, tick:0, health:100, zLayer:0,
    camera:{x:0,y:0}, cameraSmooth:0.14,
    player:{ x:0,y:0, speed:0.09, dir:'down', frame:0, frameTimer:0, w:16, h:20, target:null },
    world:null, ship:null, system:null, galaxy:null,
    highlight:null,
    stick:{active:false, dx:0, dy:0},
    selected:null,
    displayOrigin:{x:0,y:0},
    spaceTarget:null, followSelectionId:null,
    anim:null,
    originSeed:null,
    currentStarId:'S-origin'
  }
  // Expose core state for UI helpers & cheats
  try{ window.game = game; window.STATE = STATE; window.toast = toast; }catch(_){}
;

  /* Grass */
  const TILE = 16;
  function hash2(x,y){ let h = (x*73856093) ^ (y*19349663); h ^= (h >>> 13); h = (h * 1274126177) | 0; return h >>> 0; }
  function baseGrassTile(){ const [c,cx]=makeCanvas(TILE,TILE); const g1='hsl(118 42% 30%)'; const g2='hsl(118 48% 26%)'; cx.fillStyle=g1; cx.fillRect(0,0,TILE,TILE);
    for(let i=0;i<40;i++){ cx.fillStyle=(i%5===0)?g2:'rgba(255,255,255,.03)'; cx.fillRect((Math.random()*TILE)|0,(Math.random()*TILE)|0,1,1); } return c; }
  const GRASS_BASE = baseGrassTile();
  const GRASS_VARIANTS = (()=>{
    const arr = [];
    for (let i=0;i<6;i++){
      const [c,cx] = makeCanvas(TILE,TILE);
      cx.drawImage(GRASS_BASE, 0,0);
      const r = seededRandom('grass-var:'+i);
      const sign = r()<0.5 ? -1 : 1;
      const alpha = 0.035 + r()*0.045;
      cx.fillStyle = sign<0 ? `rgba(0,0,0,${alpha})` : `rgba(255,255,255,${alpha})`;
      cx.fillRect(0,0,TILE,TILE);
      // subtle extra specks
      for(let k=0;k<16;k++){
        cx.fillStyle = (k%3===0) ? 'rgba(255,255,255,.05)' : 'rgba(0,0,0,.05)';
        cx.fillRect((r()*TILE)|0, (r()*TILE)|0, 1, 1);
      }
      arr.push(c);
    }
    return arr;
  })()
  // Cached per-tile mosaic with 8x8 micro-squares (2x2 px each) and varied greens
  const GRASS_CACHE = new Map();
  function getGrassTile(gx, gy, seed){
    const key = seed+':'+gx+','+gy;
    const cached = GRASS_CACHE.get(key);
    if (cached) return cached;
    const [c,cx]=makeCanvas(TILE, TILE);
    const r = seededRandom('grass:'+seed+':'+key);
    const palette = ['hsl(118 45% 28%)','hsl(118 40% 32%)','hsl(118 38% 26%)','hsl(118 46% 34%)','hsl(118 35% 22%)','hsl(118 50% 36%)'];
    const cell = TILE/8; // 2 px when TILE=16
    for(let gy2=0; gy2<8; gy2++){
      for(let gx2=0; gx2<8; gx2++){
        const pick = r(); const idx = (pick<0.08)?4 : (pick>0.92?5 : (pick<0.45?1:(pick<0.75?0:2)));
        cx.fillStyle = palette[idx];
        cx.fillRect(gx2*cell, gy2*cell, cell, cell);
      }
    }
    // sparse specks for variation
    for(let k=0;k<8;k++){ cx.fillStyle = (k%2===0)?'rgba(255,255,255,.04)':'rgba(0,0,0,.05)'; cx.fillRect((r()*TILE)|0,(r()*TILE)|0,1,1); }
    GRASS_CACHE.set(key, c);
    if (GRASS_CACHE.size > 2500) { const first = GRASS_CACHE.keys().next().value; GRASS_CACHE.delete(first); }
    return c;
  }
;

  function generateSurface(seed){ const W=200, H=200; const tiles = new Uint8Array(W*H); for(let i=0;i<W*H;i++) tiles[i]=0; return { W,H,tile:TILE, tiles, seed }; }

/* name generator & naming (migrated) */
(function(){
  // Global-used name registry to avoid duplicates for generated names (stars only).
  const used = (window.USED_NAMES = window.USED_NAMES || new Set());

  // Generate a random name with 1–5 letters (A-Z excluding I and O) + '-' + 1–5 digits (no leading zero).
  // Uses provided seeded RNG r(). Ensures uniqueness against the used set by re-rolling.
  function uniqueRandName(r){
    const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
    function randomLetters(){
      const n = 1 + ((r()*5)|0); // 1..5
      let s = '';
      for(let i=0;i<n;i++){
        s += letters[(r()*letters.length)|0];
      }
      return s;
    }
    function randomDigits(){
      const n = 1 + ((r()*5)|0); // 1..5
      // first digit 1-9 (no leading zero)
      let s = String(1 + ((r()*9)|0));
      for(let i=1;i<n;i++){
        s += String((r()*10)|0);
      }
      return s;
    }
    let attempt = 0;
    while(true){
      attempt++;
      const candidate = randomLetters() + '-' + randomDigits();
      if(!used.has(candidate)){
        used.add(candidate);
        return candidate;
      }
      if(attempt>10000){
        // Extremely defensive fallback: append an extra random digit to break ties
        const fallback = candidate + String((r()*10)|0);
        used.add(fallback);
        return fallback;
      }
    }
  }

  // Basic Roman numerals for 1..3999 (enough for our small moon counts)
  function toRoman(n){
    const map = [
      [1000,'M'],[900,'CM'],[500,'D'],[400,'CD'],
      [100,'C'],[90,'XC'],[50,'L'],[40,'XL'],
      [10,'X'],[9,'IX'],[5,'V'],[4,'IV'],[1,'I']
    ];
    let res='';
    for(const [val,sym] of map){
      while(n>=val){ res += sym; n -= val; }
    }
    return res;
  }

  // Expose helpers
  
  // Deterministic per-key unique name: keeps a stable mapping for a given key (e.g., system or star seed).
  function uniqueNameFor(key, r){
    const map = (window.NAME_REGISTRY = window.NAME_REGISTRY || new Map());
    if (map.has(key)) return map.get(key);
    const name = uniqueRandName(r);
    map.set(key, name);
    return name;
  }
window.uniqueRandName = uniqueRandName;
  window.uniqueNameFor = uniqueNameFor;
  window.toRoman = toRoman;
})();
function randName(r){ const letters='ABCDEFGHJKLMNPQRSTUVWXYZ'; const a=letters[(r()*letters.length)|0], b=letters[(r()*letters.length)|0]; const num=(r()*899|0)+100; return `${a}${b}-${num}`; }

  /* System & galaxy (scaled orbits with constraints) */
  
/* === v0.0.81: Handcrafted Sol system (visuals dialed down 50%, factual diameters) === */
function generateSolSystem(){
  // Factual diameters (miles), nearest mile
  const DIAM_MI = { Sun:865370, Mercury:3032, Venus:7521, Earth:7926, Moon:2159, Mars:4222, Phobos:14, Deimos:8,
                    Jupiter:86881, Io:2263, Europa:1940, Ganymede:3273, Callisto:2995, Saturn:72367, Titan:3200, Enceladus:313,
                    Uranus:31518, Neptune:30599, Triton:1683 };

  // Visual scaling: previously Earth was 3x old baseline; now dial down by 50% → 1.5x
  const EARTH_R_OLD = 8;               // prior baseline in px
  const EARTH_R_VIS = Math.round(EARTH_R_OLD * 1.5);
  const VIS_FACTOR = EARTH_R_VIS / DIAM_MI.Earth; // px per mile relative to Earth
  function rFromDiam(mi){ return Math.max(4, Math.round(VIS_FACTOR * mi)); }

  // Sun visual radius scaled by same 50% factor relative to old baseline
  const sunR = Math.round(EARTH_R_OLD * (DIAM_MI.Sun / DIAM_MI.Earth) * 0.5);
  const star = { seed:'sol:star', name:'Sol', color:'#ffd26a', R:sunR, _kind:'Star', diamMi: DIAM_MI.Sun };

  // AU spacing: ensure Mercury is outside the Sun with margin; keep AU ratios
  const AU_BASE = star.R + 60;        // margin beyond photosphere
  const AU_SCALE = Math.max(220, Math.ceil((star.R + 200) / 0.387)); // so 0.387 AU is comfortably beyond Sun

  function AUtoOrbit(au){ return Math.round(AU_BASE + au * AU_SCALE); }

  function makePlanet(name, diamMi, au, seed, moons){
    const R = rFromDiam(diamMi);
    const p = { name, seed, R, orbit: AUtoOrbit(au), theta: Math.random()*Math.PI*2, color:'#aebfff',
                moons: (moons||[]).map((m,i)=>{ const mR=rFromDiam(m.diamMi); const base=Math.max(R+mR+10, 24+i*10);
                  return { name:m.name, seed:`${seed}-m${i}`, R:mR, orbit: base+16+i*10, theta: Math.random()*Math.PI*2, color:'#dde7ff', _kind:'Moon', diamMi:m.diamMi }; }),
                _kind:'Planet', diamMi };
    return p;
  }

  const planets = [
    makePlanet('Mercury', DIAM_MI.Mercury, 0.387, 'sol-mercury'),
    makePlanet('Venus',   DIAM_MI.Venus,   0.723, 'sol-venus'),
    makePlanet('Earth',   DIAM_MI.Earth,   1.000, 'sol-earth', [ {name:'Moon', diamMi: DIAM_MI.Moon} ]),
    makePlanet('Mars',    DIAM_MI.Mars,    1.524, 'sol-mars', [ {name:'Phobos', diamMi: DIAM_MI.Phobos}, {name:'Deimos', diamMi: DIAM_MI.Deimos} ]),
    makePlanet('Jupiter', DIAM_MI.Jupiter, 5.203, 'sol-jupiter', [ {name:'Io', diamMi: DIAM_MI.Io}, {name:'Europa', diamMi: DIAM_MI.Europa}, {name:'Ganymede', diamMi: DIAM_MI.Ganymede}, {name:'Callisto', diamMi: DIAM_MI.Callisto} ]),
    makePlanet('Saturn',  DIAM_MI.Saturn,  9.537, 'sol-saturn', [ {name:'Titan', diamMi: DIAM_MI.Titan}, {name:'Enceladus', diamMi: DIAM_MI.Enceladus} ]),
    makePlanet('Uranus',  DIAM_MI.Uranus,  19.191, 'sol-uranus'),
    makePlanet('Neptune', DIAM_MI.Neptune, 30.07, 'sol-neptune', [ {name:'Triton', diamMi: DIAM_MI.Triton} ])
  ];

  // Background starfield (unchanged)
  const bgRand = (function(){ let s=1234567; return ()=> (s = (1103515245*s + 12345) & 0x7fffffff, (s/0x7fffffff)); })();
  const bgStars = new Array(240).fill(0).map(()=>{ const a=bgRand()*Math.PI*2, d=300+bgRand()*2600;
    return { x: Math.cos(a)*d, y: Math.sin(a)*d, s:(bgRand()<0.85?1:2), twPhase:bgRand()*Math.PI*2, twSpeed:0.001+bgRand()*0.003 }; });

  return { seed:'sol', name:'Sol', star, planets, bgStars };
}
function generateSystem(seed){ const rand = seededRandom('sys:'+seed);
    const starName = computeStarNameForSystem(seed);
    const starTypes = [
      {type:'M', color:'#ff6a4b', r: 14},
      {type:'G', color:'#ffd26a', r: 16},
      {type:'B', color:'#9ad1ff', r: 18},
      {type:'K', color:'#ffb665', r: 15},
      {type:'A', color:'#fff8f0', r: 13}
    ];
    const starStyle = {...starTypes[(rand()*starTypes.length)|0]};
    const scaleBodies = 6;
    const scaleOrbits = 4.2;  /* a touch more spacing */
    const pCount = 3 + (rand()*4|0);
    const planets = []; let orbitR = Math.round(64 * scaleOrbits);
    let prevOrbitEdge = 0;
    for(let i=0;i<pCount;i++){
      const rawR=5+(rand()*8|0);
      const R = Math.round(rawR * scaleBodies);
      const minGap = 10;
      const minOrbitCenter = prevOrbitEdge + R + minGap;
      orbitR = Math.max(orbitR + Math.round((20 + rand()*34) * scaleOrbits), minOrbitCenter);
      const hue=(rand()*360)|0; const color=`hsl(${hue} 60% 60%)`;
      const pSeed = seed+`-p${i}`; const pName = getNameOr(pSeed, starName + String.fromCharCode(97 + i));
      const moonCount = rand()<0.9 ? (1+(rand()*3|0)) : 0;
      const moons=[];
      let lastMoonOrbitEdge = 0;
      for (let m=0;m<moonCount;m++){
        const ratio = Math.min(0.7, Math.pow(rand(), 2) * 0.7 + 0.1*rand());
        const mR = Math.max(4, Math.round(R * ratio));
        const moonGap = 6;
        let mOrbit = Math.max(lastMoonOrbitEdge + mR + moonGap, R + mR + moonGap + 6);
        mOrbit += (rand()*10)|0;
        const mSeed = pSeed+`-m${m}`; const mName = getNameOr(mSeed, `${pName}-${window.toRoman(m+1)}`);
        moons.push({ R:mR, theta: rand()*Math.PI*2, orbit: mOrbit, color:`hsl(${(hue+60+m*30)%360} 50% 70%)`, seed: mSeed, name:mName });
        lastMoonOrbitEdge = mOrbit + mR;
      }
      planets.push({ orbit: orbitR, theta: rand()*Math.PI*2, R, color, name:pName, seed:pSeed, moons });
      prevOrbitEdge = orbitR + R;
      orbitR += Math.round((22 + rand()*30) * scaleOrbits);
    }
    let maxPlanetR = Math.max(...planets.map(p=>p.R));
    const starSeed = seed+':star'; /* starName precomputed at top */
    let starR = Math.round(starStyle.r * scaleBodies); if (starR < maxPlanetR) starR = maxPlanetR + 8;
    const star = { seed: starSeed, name: starName, color: starStyle.color, R: starR };
        planets.forEach(p=>{ p._kind='Planet'; p.diamMi = Math.round(2 * p.R * 1000); (p.moons||[]).forEach(m=>{ m._kind='Moon'; m.diamMi = Math.round(2 * m.R * 1000); }); });
const bgRand = seededRandom('bg:'+seed); const bgStars = new Array(400).fill(0).map(()=>({ x:(bgRand()*6000-3000)|0, y:(bgRand()*6000-3000)|0, s: bgRand()<0.88?1:2 }));
    const sysName = starName;

    // Attach type flags and consistent diameter scale so sizes are proportional system-wide
    const __DIAM_MILES_PER_RADIUS = 5000; // single scale factor for everything
    star._kind='Star';
    star.diamMi = Math.round(2 * star.R * __DIAM_MILES_PER_RADIUS);
    planets.forEach(p=>{
      p._kind='Planet';
      p.diamMi = Math.round(2 * p.R * __DIAM_MILES_PER_RADIUS);
      (p.moons||[]).forEach(m=>{
        m._kind='Moon';
        m.diamMi = Math.round(2 * m.R * __DIAM_MILES_PER_RADIUS);
      });
    });
    return { seed, name: sysName, star, planets, bgStars };
  }

  function generateGalaxy(seed, originSeed, originName){ 
    const rand = seededRandom('galaxy:'+seed); 
    const stars = [];
    // Ensure origin uses the SYSTEM seed (no ':star' suffix)
    const originSystemSeed = originSeed || (seed+':home');
    const originResolvedName = getNameOr(originSystemSeed, originName || 'Origin');
    const origin = { id:`S-origin`, x:0, y:0, seed: originSystemSeed, name: originResolvedName, isOrigin:true };
    stars.push(origin);
    for(let i=1;i<=200;i++){ 
      const sSeed = seed+'-'+i; 
      const sName = getNameOr(sSeed, window.uniqueNameFor(sSeed, rand));
      stars.push({ id:`S-${i}`, x:(rand()*6000-3000)|0, y:(rand()*6000-3000)|0, seed: sSeed, name:sName, isOrigin:false }); 
    }
    const bgRand = seededRandom('bg:'+seed); const bgStars = new Array(400).fill(0).map(()=>({ x:(bgRand()*6000-3000)|0, y:(bgRand()*6000-3000)|0, s: bgRand()<0.88?1:2 }));
    return { seed, stars, cells:new Map(), lastCellTouch:new Map(), ship:{x:origin.x, y:origin.y-60, speed:1.4}, target:null, freeTarget:null, originId: origin.id, bgStars };
  }
function clear(c='#000'){ ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over'; ctx.setTransform(DPR,0,0,DPR,0,0); ctx.fillStyle=c; ctx.fillRect(0,0,VIEW_W,VIEW_H); }
  function drawLabel(text, x, y){ ctx.font = '12px ui-monospace'; ctx.textBaseline = 'middle'; const pad = 6; const w = Math.round(ctx.measureText(text).width) + pad*2; const h = 18; const rx = Math.round(x - w/2); const ry = Math.round(y - h - 6); ctx.fillStyle = 'rgba(11,15,31,.9)'; roundRect(rx, ry, w, h, 9, true, false); ctx.strokeStyle = '#2a3050'; ctx.lineWidth = 1; roundRect(rx, ry, w, h, 9, false, true); ctx.fillStyle = '#e8f1ff'; ctx.fillText(text, Math.round(x - w/2 + pad), Math.round(ry + h/2)); }
  function roundRect(x, y, w, h, r, fill, stroke){ ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+w, y, x+w, y+h, r); ctx.arcTo(x+w, y+h, x, y+h, r); ctx.arcTo(x, y+h, x, y, r); ctx.arcTo(x, y, x+w, y, r); ctx.closePath(); if (fill) ctx.fill(); if (stroke) ctx.stroke(); }

  function drawSurface(world, camx, camy){
  // === 0.0.57 terrain (Perlin continents + fine texels from 0.0.49) ===
  try{
    if (typeof hideInfoButtons==='function') hideInfoButtons();
    if (typeof clear==='function') clear('#05060a');

    function clamp01(v){ return v<0?0:(v>1?1:v); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function mixRGB(a,b,t){ return [lerp(a[0],b[0],t), lerp(a[1],b[1],t), lerp(a[2],b[2],t)]; }
    function fnv1a32(s){ let h=0x811c9dc5>>>0; for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,0x01000193);} return h>>>0; }
    function lcg(next){ return (1664525*next + 1013904223)>>>0; }

    if (!world.__bodyHash) world.__bodyHash = fnv1a32(String(world.seed||0));
    const bodyHash = world.__bodyHash;
    if (!world.__perm){
      let rnd = (bodyHash||1)>>>0;
      const p = new Uint8Array(512);
      const base = new Uint8Array(256);
      for (let i=0;i<256;i++) base[i]=i;
      for (let i=255;i>0;i--){ rnd = lcg(rnd); const j = rnd % (i+1); const t = base[i]; base[i]=base[j]; base[j]=t; }
      for (let i=0;i<512;i++) p[i] = base[i&255];
      world.__perm = p;
    }
    const perm = world.__perm;
    function fade(t){ return t*t*t*(t*(t*6-15)+10); }
    function grad(h, x, y){
      switch(h & 7){
        case 0: return  x + y;
        case 1: return  x - y;
        case 2: return -x + y;
        case 3: return -x - y;
        case 4: return  x;
        case 5: return -x;
        case 6: return  y;
        default:return -y;
      }
    }
    function perlin2(x, y){
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      const xf = x - Math.floor(x);
      const yf = y - Math.floor(y);
      const u = fade(xf), v = fade(yf);
      const aa = perm[X   + perm[Y  ]];
      const ab = perm[X   + perm[Y+1]];
      const ba = perm[X+1 + perm[Y  ]];
      const bb = perm[X+1 + perm[Y+1]];
      const x1 = lerp(grad(aa, xf  , yf  ), grad(ba, xf-1, yf  ), u);
      const x2 = lerp(grad(ab, xf  , yf-1), grad(bb, xf-1, yf-1), u);
      return lerp(x1, x2, v);
    }
    function fbmPerlin(x, y, oct, freq, gain){
      let amp=0.5, f=freq, sum=0, norm=0;
      for (let i=0;i<oct;i++){ sum += amp * perlin2(x*f, y*f); norm += amp; amp *= gain; f *= 2.0; }
      return sum/(norm||1);
    }
    function ridged(x,y,oct,freq,gain){
      let amp=0.5, f=freq, sum=0, norm=0;
      for (let i=0;i<oct;i++){ let n = perlin2(x*f, y*f); n = 1.0 - Math.abs(n); sum += amp * n; norm += amp; amp *= gain; f *= 2.0; }
      return sum/(norm||1);
    }
    function domainWarp(x, y, f, amp){
      const wx = perlin2(x*f, y*f) * amp;
      const wy = perlin2((x+1000)*f, (y-777)*f) * amp;
      return [x + wx, y + wy];
    }

    const tint = (world.tintRGB && world.tintRGB.length>=3) ? world.tintRGB : [96,128,96];
    const arche = ['ice','desert','oceanic','temperate','tundra','rocky'][(bodyHash>>>24)%6];
    let tempShift=0, moistShift=0, waterBias=0, slopeBias=0, grassChance=1.0;
    if (arche==='ice'){ tempShift=-0.30; moistShift=+0.05; waterBias=+0.03; slopeBias=0.1; grassChance=0.05; }
    if (arche==='desert'){ tempShift=+0.25; moistShift=-0.25; waterBias=-0.08; slopeBias=0.0; grassChance=0.12; }
    if (arche==='oceanic'){ tempShift=+0.05; moistShift=+0.20; waterBias=+0.10; slopeBias=0.0; grassChance=1.0; }
    if (arche==='temperate'){ tempShift=0.00; moistShift=0.00; waterBias=0.00; slopeBias=0.0; grassChance=1.0; }
    if (arche==='tundra'){ tempShift=-0.20; moistShift=-0.05; waterBias=+0.00; slopeBias=0.0; grassChance=0.25; }
    if (arche==='rocky'){ tempShift=-0.05; moistShift=-0.05; waterBias=-0.02; slopeBias=+0.25; grassChance=0.25; }

    window.__terrainCache = window.__terrainCache || {};
    const cache = window.__terrainCache;

    const tileSize = 256;
    const halfW = VIEW_W/2, halfH = VIEW_H/2;
    const startX = Math.floor((camx - halfW)/tileSize);
    const startY = Math.floor((camy - halfH)/tileSize);
    const endX   = Math.floor((camx + halfW)/tileSize);
    const endY   = Math.floor((camy + halfH)/tileSize);
    const TEX = 112;
    // Reusable scratch to avoid per-tile allocations (reduces GC spikes)
    window.__tileScratch = window.__tileScratch || (function(){
      const small = document.createElement('canvas'); small.width=TEX; small.height=TEX;
      const sg = small.getContext('2d', {alpha:false});
      const img = sg.createImageData(TEX, TEX);
      return { small, sg, img };
    })();
    const __SCR = window.__tileScratch;

    const CONT_FREQ = 0.0006;
    const CONT_WARP_FREQ = 0.0008;
    const CONT_WARP_AMP  = 120.0;
    const ELEV_FREQ = 0.0035;
    const MOIST_FREQ=0.0020;
    const TEMP_FREQ =0.0016;
    const MICRO1=0.02, MICRO2=0.05;

    const PAL = {
      water:{base:[26,88,170],accent:[40,120,200]},
      ice:{base:[175,205,230],accent:[210,235,255]},
      snow:{base:[240,246,252],accent:[205,220,235]},
      sand:{base:[205,178,120],accent:[232,206,146]},
      dirt:{base:[126,96,62],accent:[152,118,79]},
      grass:{base:[68,128,74],accent:[96,156,98]},
      rock:{base:[110,110,110],accent:[140,140,140]},
      swamp:{base:[60,92,60],accent:[82,116,82]}
    };
    function tintMix(rgb, amt){ const m=mixRGB(rgb,tint,amt); return [m[0]|0,m[1]|0,m[2]|0]; }
    function classify(elev,temp,moist,slope,waterline,allowGrass,patch){
      if (elev < waterline) return (temp < 0.32) ? 'ice' : 'water';
      if (temp < 0.27) return (patch>0.35) ? 'snow' : 'rock';
      if (moist < 0.28) return (patch>0.25) ? 'sand' : (slope>0.6 ? 'rock':'dirt');
      if (allowGrass && patch < 0.9) return 'grass';
      return (slope>0.65 ? 'rock' : (moist>0.75 ? 'swamp' : 'dirt'));
    }

    if (ctx && 'imageSmoothingEnabled' in ctx) ctx.imageSmoothingEnabled = false;

    for (let cy=startY; cy<=endY; cy++){
      for (let cx=startX; cx<=endX; cx++){
        const key = cx+','+cy+':p50:'+bodyHash+':'+arche;
        let tile = cache[key];
        if (!tile){
          const small = __SCR.small; const sg = __SCR.sg; const img = __SCR.img;

          let k=0;
          for (let ty=0; ty<TEX; ty++){
            for (let tx=0; tx<TEX; tx++){
              const wx = cx*tileSize + (tx + 0.5)*(tileSize/TEX);
              const wy = cy*tileSize + (ty + 0.5)*(tileSize/TEX);

              const [wxw, wyw] = domainWarp(wx, wy, CONT_WARP_FREQ, CONT_WARP_AMP);
              const cont = clamp01( (fbmPerlin(wxw, wyw, 3, CONT_FREQ, 0.5)+1)*0.5 );

              const elevHF = clamp01( (fbmPerlin(wx, wy, 4, ELEV_FREQ, 0.5)+1)*0.5 );
              const ridg   = ridged(wx, wy, 3, ELEV_FREQ*0.7, 0.5);
              let elev = clamp01( 0.55*cont + 0.35*elevHF + 0.10*ridg );

              const e_dx = clamp01( (fbmPerlin(wx+3, wy, 3, ELEV_FREQ, 0.5)+1)*0.5 ) - elevHF;
              const e_dy = clamp01( (fbmPerlin(wx, wy+3, 3, ELEV_FREQ, 0.5)+1)*0.5 ) - elevHF;
              let slope = Math.min(1, Math.hypot(e_dx,e_dy)*5 + slopeBias);

              const baseTemp = ((bodyHash>>>8)&255)/255;
              const baseMoist= ((bodyHash>>>16)&255)/255;
              let temp = clamp01( (fbmPerlin(wx+10000, wy-7000, 3, TEMP_FREQ, 0.5)+1)*0.5 * 0.7 + baseTemp*0.3 + tempShift - elev*0.30 );
              let moist= clamp01( (fbmPerlin(wx-5000, wy+9000, 3, MOIST_FREQ, 0.5)+1)*0.5 * 0.7 + baseMoist*0.3 + moistShift );

              const waterline = 0.48 + waterBias - 0.08*(arche==='oceanic');
              const patch = clamp01( (fbmPerlin(wx+777, wy-333, 2, 0.004, 0.5)+1)*0.5 );
              const allowGrass = (arche==='temperate' || arche==='oceanic' || arche==='rocky' || arche==='tundra') && (grassChance>0.05);

              const biome = classify(elev,temp,moist,slope,waterline,allowGrass,patch);
              const pal = PAL[biome];

              const n1 = clamp01( (perlin2(wx*MICRO1, wy*MICRO1)+1)*0.5 );
              const n2 = clamp01( (perlin2((wx+133)*MICRO2, (wy-77)*MICRO2)+1)*0.5 );

              let t = Math.max(0, Math.min(1, 0.35 + 0.25*n1 + 0.15*n2));
              let rgb = mixRGB(pal.base, pal.accent, t);

              if (biome==='sand'){
                const rip = Math.sin(wx*0.03 + n2*6.283)*0.05; rgb = mixRGB(rgb, [255,230,170], 0.06+rip);
              } else if (biome==='dirt'){
                const cl = (0.5-n1)*0.12; rgb=[rgb[0]*(1-cl), rgb[1]*(1-cl), rgb[2]*(1-cl)];
              } else if (biome==='grass'){
                const sp = n1*n2; rgb = mixRGB(rgb, [40,80,40], (sp>0.6)?0.10:0.04);
              } else if (biome==='rock'){
                const s = Math.min(1, slope*0.9); rgb = mixRGB(rgb, [120,130,140], 0.25+0.35*s);
              } else if (biome==='snow'){
                const sh = (0.5-n2)*0.18; rgb = mixRGB(rgb, [180,200,230], sh);
              } else if (biome==='ice'){
                const crack = (n1>0.82 || n2>0.85) ? 0.20 : 0.0; rgb = mixRGB(rgb, [210,240,255], 0.12+crack);
              } else if (biome==='water'){
                const depth = Math.max(0, waterline - elev + 0.12); rgb = mixRGB(rgb, [12,40,80], Math.min(0.9, depth));
                const sh2 = Math.sin(wx*0.025) * Math.cos(wy*0.025) * 0.05; rgb = mixRGB(rgb, [200,220,255], Math.max(0, sh2));
              } else if (biome==='swamp'){
                const murk = 0.08 + 0.15*n2; rgb = mixRGB(rgb, [30,50,30], murk);
              }

              if (biome!=='water' && biome!=='ice'){
                const amt = (biome==='snow')?0.08 : (biome==='sand'?0.18:0.30);
                rgb = mixRGB(rgb, tint, amt);
              }

              img.data[k++] = rgb[0]|0;
              img.data[k++] = rgb[1]|0;
              img.data[k++] = rgb[2]|0;
              img.data[k++] = 255;
            }
          }
          sg.putImageData(img,0,0);
          tile = document.createElement('canvas'); tile.width=tileSize; tile.height=tileSize;
          const tg = tile.getContext('2d', {alpha:false}); tg.imageSmoothingEnabled = false;
          tg.drawImage(small, 0,0, tileSize, tileSize);
          cache[key] = tile;
        }
        const dx = Math.round(cx*tileSize - (camx - halfW));
        const dy = Math.round(cy*tileSize - (camy - halfH));
        ctx.drawImage(tile, dx, dy);
      }
    }
  }catch(e){ try{ if (typeof clear==='function') clear('#05060a'); }catch(_){ } }
}

// global noise helpers for terrain
const terrainCache = {};
function fnv1a32(s){ let h = 0x811c9dc5>>>0; for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 0x01000193); } return h>>>0; }
function prng32(seed){ let x = seed>>>0; return function(){ x|=0; x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return ((x>>>0)/4294967296); }; }
  function drawPlayer(px, py, dir, frame){ const row = ({down:0, up:1, right:2, left:3})[dir] || 0; const sx=(frame%3)*16, sy=row*20; ctx.drawImage(playerSprite, sx, sy, 16, 20, Math.round(px - 8), Math.round(py - 16), 16, 20); }
  function drawShip(x,y){ if (game && game.hideShipDuringLand) return; ctx.drawImage(shipSprite, Math.round(x - 12), Math.round(y - 7)); }
  function drawBodyRing(x,y,R,isSelected,isNear){ if (!isSelected && !isNear) return; ctx.strokeStyle = isSelected ? '#64e1ff' : '#5effa1'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(Math.round(x), Math.round(y), Math.round(R+4), 0, Math.PI*2); ctx.stroke(); }

  function updateInfoButtonsDuringSpace(system, camx, camy){
    try {
      if (!infoBtnStar || !infoBtnBody) return;
      if (game.state !== STATE.SPACE) { hideInfoButtons(); return; }

      // Approx label metrics & desired extra spacing
      const LABEL_HALF = 14; // ~28px full
      const GAP = 16;        // extra clearance

      // Label anchor centers used by drawLabel(...)
      const cxp = VIEW_W/2 - camx;
      const cyp = VIEW_H/2 - camy;
      const starLabelX = cxp;
      const starLabelY = cyp - (system.star?.R || 12) - 6;

      // Star button above and centered
      infoBtnStar.style.display = 'block';
      const sbw = infoBtnStar.offsetWidth || 44;
      const sbh = infoBtnStar.offsetHeight || 22;
      infoBtnStar.style.left = Math.round(starLabelX - sbw/2) + 'px';
      infoBtnStar.style.top  = Math.round(starLabelY - LABEL_HALF - sbh - GAP) + 'px';

      // Selected planet/moon button above and centered
      if (game.selected && (game.selected.type==='planet' || game.selected.type==='moon')){
        const pos = getBodyScreenPos(game.selected);
        const R = (game.selected.ref?.R || 10);
        const labelX = (pos?.x ?? (VIEW_W/2));
        const labelY = (pos?.y ?? (VIEW_H/2)) - R - 6;
        const atCenter = pos ? (Math.hypot(pos.x - VIEW_W/2, pos.y - VIEW_H/2) < 1) : false;
        if (atCenter) { infoBtnBody.style.display = 'block'; } else { infoBtnBody.style.display = 'none'; }
        const bbw = infoBtnBody.offsetWidth || 44;
        const bbh = infoBtnBody.offsetHeight || 22;
        infoBtnBody.style.left = Math.round(labelX - bbw/2) + 'px';
        infoBtnBody.style.top  = Math.round(labelY - LABEL_HALF - bbh - GAP) + 'px';
      } else {
        infoBtnBody.style.display = 'none';
      }
    } catch(e){
      hideInfoButtons();
    }
  }
  
/* === 0.0.72: Planet/Moon texture helpers (Perlin-based) === */
function _hash32(str){
  let h=2166136261>>>0;
  for(let i=0;i<str.length;i++){ h^=str.charCodeAt(i); h = Math.imul(h, 16777619); }
  return h>>>0;
}
function _makePerlin2(seedStr){
  let rnd = (_hash32(seedStr)||1)>>>0;
  const p = new Uint8Array(512);
  const base = new Uint8Array(256);
  for (let i=0;i<256;i++) base[i]=i;
  for (let i=255;i>0;i--){ rnd = (1664525*rnd + 1013904223)>>>0; const j = rnd % (i+1); const t=base[i]; base[i]=base[j]; base[j]=t; }
  for (let i=0;i<512;i++) p[i] = base[i&255];
  function fade(t){ return t*t*t*(t*(t*6-15)+10); }
  function grad(h,x,y){ switch(h&7){ case 0:return x; case 1:return -x; case 2:return y; case 3:return -y; case 4:return x+y; case 5:return -x+y; case 6:return x-y; default:return -x-y; } }
  return function perlin2(x,y){
    const X = (Math.floor(x)&255), Y = (Math.floor(y)&255);
    x -= Math.floor(x); y -= Math.floor(y);
    const u = fade(x), v = fade(y);
    const A = p[X]+Y, AA=p[A], AB=p[A+1], B=p[X+1]+Y, BA=p[B], BB=p[B+1];
    const g1 = grad(p[AA], x, y), g2 = grad(p[BA], x-1, y), g3 = grad(p[AB], x, y-1), g4 = grad(p[BB], x-1, y-1);
    const lerp = (a,b,t)=>a+(b-a)*t;
    const nx1 = lerp(g1, g2, u), nx2 = lerp(g3, g4, u);
    return lerp(nx1, nx2, v);
  };
}
function _bodyArchetypeFromSeed(seedStr){
  const h = _hash32(seedStr);
  return ['ice','desert','oceanic','temperate','tundra','rocky'][(h>>>24)%6];
}
function _planetTexturePalette(baseHex, arche){
  // baseHex like 'hsl(... )' or '#rrggbb'. For simplicity, use soft palettes by arche and tint by base.
  // Return {water:[r,g,b], land:[r,g,b], rock:[r,g,b], ice:[r,g,b]}
  function hexToRgb(hex){
    if (!hex || hex[0]!=='#') return null;
    const v = parseInt(hex.slice(1),16); return [ (v>>16)&255, (v>>8)&255, v&255 ];
  }
  function parseColor(c){
    const m = /#([0-9a-f]{6})/i.exec(c||''); if (m) return hexToRgb(m[0]);
    // fallback blues/greens
    return [180,200,230];
  }
  const base = parseColor(baseHex);
  const t = (x)=>Math.max(0,Math.min(255,x));
  const mul = (rgb, f)=>[t(rgb[0]*f), t(rgb[1]*f), t(rgb[2]*f)];
  const add = (a,b)=>[t(a[0]+b[0]), t(a[1]+b[1]), t(a[2]+b[2])];
  switch(arche){
    case 'ice':       return { water: mul(base,0.7), land: add(mul(base,0.9),[40,60,80]), rock: mul(base,0.6), ice: [220,235,255] };
    case 'desert':    return { water: [80,120,160], land: [210,180,120], rock:[160,130,90], ice:[230,230,240] };
    case 'oceanic':   return { water: mul(base,0.9), land: [90,140,90],  rock:[100,110,120], ice:[230,240,250] };
    case 'tundra':    return { water: [90,120,150], land: [130,140,150], rock:[130,120,120], ice:[235,240,255] };
    case 'rocky':     return { water: [70,90,120],  land: [140,110,90],  rock:[120,100,90],  ice:[230,235,240] };
    default:          return { water: [90,120,150], land: [100,150,100], rock:[120,110,100], ice:[230,240,250] };
  }
}
function _ensureBodyTexture(body, baseColor){
  // Cache by radius + seed
  const cacheKey = body.seed + '::' + (body.R||0);
  if (body._texKey === cacheKey && body._tex) return;
  const R = Math.max(3, body.R|0);
  const S = R*2;
  const off = document.createElement('canvas'); off.width = off.height = S;
  const g = off.getContext('2d', { willReadFrequently:true });
  // Build perlin for this body
  const per = _makePerlin2(body.seed || (''+Math.random()));
  // Archetype & palette
  const arche = _bodyArchetypeFromSeed(body.seed||'x');
  const pal = _planetTexturePalette(baseColor, arche);
  // Render spherical-projected texture
  const cx = R, cy = R;
  const img = g.createImageData(S, S);
  const data = img.data;
  for (let j=0;j<S;j++){
    for (let i=0;i<S;i++){
      const dx = (i - cx + 0.5), dy = (j - cy + 0.5);
      const rr = dx*dx + dy*dy;
      const idx = (j*S + i) * 4;
      if (rr > R*R){
        data[idx+3] = 0; continue;
      }
      const nx = dx / R, ny = dy / R;
      const nz2 = 1 - nx*nx - ny*ny;
      const nz = nz2>0 ? Math.sqrt(nz2) : 0;
      // map to 2D noise domain using projected normal
      const u = nx*1.6; const v = ny*1.6;
      // fbm
      let n = 0, amp = 0.55, f=0.9, norm=0;
      for(let k=0;k<4;k++){ n += amp * per(u*f + 12.3, v*f - 9.7); norm += amp; amp *= 0.55; f *= 2.05; }
      n = (n/(norm||1))*0.5 + 0.5; // 0..1
      // slight domain warp
      const w = per(u*0.6+100, v*0.6-77)*0.12;
      const m = Math.max(0, Math.min(1, n + w));
      // Decide biome/altitude
      const sea = 0.48;
      const rocky = 0.74;
      let rgb;
      if (m < sea){ rgb = pal.water; }
      else if (m > rocky){ rgb = pal.rock; }
      else { rgb = pal.land; }
      // simple lighting by normal (nz)
      const shade = 0.55 + nz*0.45;
      const r = Math.min(255, rgb[0]*shade)|0;
      const gch = Math.min(255, rgb[1]*shade)|0;
      const b = Math.min(255, rgb[2]*shade)|0;
      data[idx] = r; data[idx+1] = gch; data[idx+2] = b; data[idx+3] = 255;
    }
  }
  g.putImageData(img, 0, 0);
  body._tex = off; body._texKey = cacheKey;
}

function drawSpace(system, camx, camy){ clear('#04070d'); ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over'; // Twinkling background stars
for(const s of system.bgStars){
  const x = VIEW_W/2 + (s.x - camx/4), y = VIEW_H/2 + (s.y - camy/4);
  const ix = Math.round(((x % VIEW_W)+VIEW_W)%VIEW_W), iy = Math.round(((y % VIEW_H)+VIEW_H)%VIEW_H);
  const ph = (((s.x*374761393) ^ (s.y*668265263)) & 1023) / 1023 * Math.PI*2;
  const t = (game._now || performance.now()) * (s.s===2 ? 0.0020 : 0.0015);
  const a = 0.55 + 0.45 * Math.sin(ph + t);
  ctx.globalAlpha = a;
  ctx.fillStyle = (s.s===2 ? '#dff4ff' : '#c7e0ff');
  ctx.fillRect(ix, iy, s.s, s.s);
}
ctx.globalAlpha = 1;
    // Shooting star spawner & renderer (background layer)
    (function(){
      if (!system._shoot){ system._shoot = { active:false, next: 0, x:0,y:0,vx:0,vy:0, life:0, _last: 0 }; }
      const now = (game._now || performance.now());
      if (!system._shoot.active){
        if (system._shoot.next === 0 || now > system._shoot.next){
          system._shoot.next = now + 10000; // every 10s
          const margin = 40;
          const edge = (Math.random()*4)|0;
          const speed = 0.28 + Math.random()*0.18; // px/ms
          let x=0,y=0,vx=0,vy=0;
          if (edge===0){ x = -margin; y = Math.random()*VIEW_H; }
          else if (edge===1){ x = VIEW_W+margin; y = Math.random()*VIEW_H; }
          else if (edge===2){ y = -margin; x = Math.random()*VIEW_W; }
          else { y = VIEW_H+margin; x = Math.random()*VIEW_W; }
          const ang = Math.random()*Math.PI*2;
          vx = Math.cos(ang)*speed; vy = Math.sin(ang)*speed;
          if (edge===0 && vx<=0) vx = -vx;
          if (edge===1 && vx>=0) vx = -vx;
          if (edge===2 && vy<=0) vy = -vy;
          if (edge===3 && vy>=0) vy = -vy;
          system._shoot = { active:true, next: system._shoot.next, x, y, vx, vy, life: 900 + Math.random()*900, _last: now, col: (['#ffffff','#ffa652','#ff5e5e'][(Math.random()*3)|0]), len: 20 + Math.random()*70, lw: (Math.random()<0.5?1:2) };
        }
      } else {
        const dt =  Math.max(8, Math.min(50, now - (system._shoot._last||now-16)));
        system._shoot._last = now;
        system._shoot.life -= dt;
        system._shoot.x += system._shoot.vx * dt;
        system._shoot.y += system._shoot.vy * dt;
        // draw
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, system._shoot.life/600));
        ctx.strokeStyle = system._shoot.col;
        ctx.lineWidth = system._shoot.lw;
        const len = system._shoot.len;
        ctx.beginPath();
        ctx.moveTo(system._shoot.x, system._shoot.y);
        ctx.lineTo(system._shoot.x - system._shoot.vx*len*16, system._shoot.y - system._shoot.vy*len*16);
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.restore();
        if (system._shoot.life <= 0 || system._shoot.x < -60 || system._shoot.x > VIEW_W+60 || system._shoot.y < -60 || system._shoot.y > VIEW_H+60){
          system._shoot.active = false;
        }
      }
    })();
    const cxp = VIEW_W/2 - camx; const cyp = VIEW_H/2 - camy;
// Sun glow (toned down)
const glowR = system.star.R * 2.0;
const gGrad = ctx.createRadialGradient(Math.round(cxp), Math.round(cyp), system.star.R*0.8, Math.round(cxp), Math.round(cyp), glowR);
gGrad.addColorStop(0.0, system.star.color);
gGrad.addColorStop(0.35, system.star.color);
gGrad.addColorStop(1.0, 'rgba(255,255,255,.0)');
ctx.save(); ctx.globalAlpha = 0.20; ctx.fillStyle = gGrad;
ctx.beginPath(); ctx.arc(Math.round(cxp), Math.round(cyp), glowR, 0, Math.PI*2); ctx.fill(); ctx.restore();
// Star disc
ctx.globalAlpha = 1; ctx.fillStyle=system.star.color; ctx.beginPath(); ctx.arc(Math.round(cxp), Math.round(cyp), system.star.R, 0, Math.PI*2); ctx.fill();
// Sunspots: static centers, irregular shapes, slow 10–30s grow & 10–30s shrink, <=3, non-overlapping
(function(){
  const R = system.star.R;
  const rMin = Math.max(1, R*0.02), rMax = Math.max(2, R*0.10);
  const now = (game._now||performance.now());
  if (!system._sunspots) { system._sunspots = []; system._sun_next = now + 3000 + Math.random()*4000; system._sun_last = now; }
  const dt = Math.max(8, Math.min(50, now - (system._sun_last||now-16))); system._sun_last = now;

  // Spawn new spot if room and timer elapsed
  if (system._sunspots.length < 3 && now >= system._sun_next){
    system._sun_next = now + 5000 + Math.random()*8000;
    let tries = 40;
    while (tries--){
      const ang = Math.random()*Math.PI*2;
      const dist = Math.random()*(R - rMax - 2);
      const lx = Math.cos(ang)*dist, ly = Math.sin(ang)*dist;
      // enforce non-overlap using max radius budget
      let ok = true;
      for (const s of system._sunspots){
        const d = Math.hypot(lx - s.lx, ly - s.ly);
        if (d < (s.rMax + rMax + 2)) { ok = false; break; }
      }
      if (ok) {
        const target = rMin + Math.random()*(rMax - rMin);
        const growMs = 10000 + Math.random()*20000;  // 10–30s to grow
        const shrinkMs = 10000 + Math.random()*20000; // 10–30s to shrink
        // irregular ellipse parameters
        const rxScale = 0.8 + Math.random()*0.8;  // 0.8..1.6
        const ryScale = 0.8 + Math.random()*0.8;
        const rot = Math.random()*Math.PI;
        system._sunspots.push({
          lx, ly,
          r: Math.max(1, rMin*0.6),
          rTarget: target,
          rMax: rMax,
          phase: 'grow',
          growMs, shrinkMs,
          t: 0, // phase time accumulator
          rxScale, ryScale, rot,
          alpha: 0.96
        });
        break;
      }
    }
  }

  // Update & draw existing
  for (let i=system._sunspots.length-1; i>=0; i--){
    const s = system._sunspots[i];
    // advance phase timer
    const inc = dt;
    if (s.phase==='grow'){
      s.t += inc;
      const p = Math.min(1, s.t / s.growMs);
      s.r = Math.max(1, Math.min(s.rMax, rMin*0.6 + (s.rTarget - rMin*0.6) * p));
      if (p >= 1){ s.phase = 'shrink'; s.t = 0; }
    } else { // shrink
      s.t += inc;
      const p = Math.min(1, s.t / s.shrinkMs);
      s.r = Math.max(1, Math.min(s.rMax, s.rTarget + (rMin*0.6 - s.rTarget) * p));
      if (p >= 1){ system._sunspots.splice(i,1); continue; }
    }
    const sx = Math.round(cxp + s.lx), sy = Math.round(cyp + s.ly);
    // draw as irregular ellipse (almost black)
    ctx.save();
    ctx.globalAlpha = s.alpha;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    const rx = Math.min(s.rMax, s.r * s.rxScale);
    const ry = Math.min(s.rMax, s.r * s.ryScale);
    ctx.ellipse(sx, sy, rx, ry, s.rot, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
})();drawLabel(system.star.name, cxp, cyp - system.star.R - 6);
    ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
    system.planets.forEach(p=>{ const x = cxp + Math.cos(p.theta)*p.orbit; const y = cyp + Math.sin(p.theta)*p.orbit; ctx.strokeStyle='#1b223a'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(Math.round(cxp), Math.round(cyp), p.orbit, 0, Math.PI*2); ctx.stroke();
      if (p.R >= 4) {
  _ensureBodyTexture(p, p.color);
  ctx.save();
  ctx.beginPath(); ctx.arc(Math.round(x), Math.round(y), p.R, 0, Math.PI*2); ctx.clip();
  ctx.drawImage(p._tex, Math.round(x - p.R), Math.round(y - p.R), p.R*2, p.R*2);
  ctx.restore();
} else {
  ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(Math.round(x), Math.round(y), p.R, 0, Math.PI*2); ctx.fill();
}
      p.moons.forEach(m=>{ const mx=x+Math.cos(m.theta)*m.orbit, my=y+Math.sin(m.theta)*m.orbit; ctx.strokeStyle='#26314e'; ctx.lineWidth=1; ctx.beginPath(); ctx.arc(Math.round(x), Math.round(y), m.orbit, 0, Math.PI*2); ctx.stroke();
        if (m.R >= 3) {
  _ensureBodyTexture(m, m.color);
  ctx.save();
  ctx.beginPath(); ctx.arc(Math.round(mx), Math.round(my), m.R, 0, Math.PI*2); ctx.clip();
  ctx.drawImage(m._tex, Math.round(mx - m.R), Math.round(my - m.R), m.R*2, m.R*2);
  ctx.restore();
} else {
  ctx.fillStyle=m.color; ctx.beginPath(); ctx.arc(Math.round(mx), Math.round(my), m.R, 0, Math.PI*2); ctx.fill();
}
        const dMoon = Math.hypot(mx - VIEW_W/2, my - VIEW_H/2) - m.R; const isSelected = game.selected && game.selected.type==='moon' && game.selected.ref.seed===m.seed; drawBodyRing(mx,my,m.R,isSelected, dMoon<16); if (isSelected) drawLabel(m.name, mx, my- m.R - 6); });
      const d = Math.hypot(x - VIEW_W/2, y - VIEW_H/2) - p.R; const isSelected = game.selected && game.selected.type==='planet' && game.selected.ref.seed===p.seed; drawBodyRing(x,y,p.R,isSelected, d<16); if (isSelected) drawLabel(p.name, x, y - p.R - 6); });
    if (game.selected && game.selected.type==='star'){ drawLabel(game.selected.ref.name + (game.selected.ref.isOrigin?' • Origin':''), cxp, cyp - system.star.R - 6); }
    drawShip(VIEW_W/2, VIEW_H/2);
    updateInfoButtonsDuringSpace(system, camx, camy);
  }

  /* === Hyperspace streaming (Minecraft-style chunks) === */
  function galaxyCellKey(cx, cy){ return cx+','+cy; }
  function generateGalaxyCell(galaxy, cx, cy){
    const key = galaxyCellKey(cx, cy);
    if (galaxy.cells.has(key)) return galaxy.cells.get(key);
    const CELL = 1200;
    const dens = Math.max(0.01, Math.min(1, game.galaxyDensity||1));
    const r = seededRandom('galaxy:'+galaxy.seed+':'+Math.round(dens*100)+':cell:'+key);
    const base = 80 + ((r()*40)|0);
    const count = Math.max(1, Math.round(base * dens));
    const stars = [];
    for (let i=0;i<count;i++){
      const ox = (r()*CELL)|0, oy=(r()*CELL)|0;
      const sSeed = galaxy.seed+':c'+key+':i'+i;
      stars.push({ id:`S-${key}-${i}`, x: cx*CELL + ox, y: cy*CELL + oy, seed:sSeed, isOrigin:false });
    }
    galaxy.cells.set(key, stars);
    return stars;
  }
  function getStarsInView(galaxy){
    const CELL = 1200;
    const PAD = 200;
    const minx = Math.floor((galaxy.ship.x - VIEW_W/2 - PAD) / CELL);
    const maxx = Math.floor((galaxy.ship.x + VIEW_W/2 + PAD) / CELL);
    const miny = Math.floor((galaxy.ship.y - VIEW_H/2 - PAD) / CELL);
    const maxy = Math.floor((galaxy.ship.y + VIEW_H/2 + PAD) / CELL);
    const out = [];
    for (let cy=miny; cy<=maxy; cy++){
      for (let cx=minx; cx<=maxx; cx++){
        const key = galaxyCellKey(cx, cy);
        const arr = generateGalaxyCell(galaxy, cx, cy);
        if (typeof game?.tick === 'number') galaxy.lastCellTouch.set(key, game.tick);
        const lx = galaxy.ship.x - VIEW_W/2 - PAD, rx = galaxy.ship.x + VIEW_W/2 + PAD;
        const ty = galaxy.ship.y - VIEW_H/2 - PAD, by = galaxy.ship.y + VIEW_H/2 + PAD;
        for (let s of arr){ if (s.x >= lx && s.x <= rx && s.y >= ty && s.y <= by) out.push(s); }
      }
    }
    const EVICT_AFTER = 600;
    if (galaxy.lastCellTouch && galaxy.lastCellTouch.size > 64){
      const now = typeof game?.tick === 'number' ? game.tick : 0;
      for (const [key, t] of galaxy.lastCellTouch){
        if (now - t > EVICT_AFTER){ galaxy.lastCellTouch.delete(key); galaxy.cells.delete(key); }
      }
    }
      // Include origin star if on-screen
    try {
      const origin = (galaxy.stars && galaxy.stars.find(s=>s.isOrigin)) || {x:0,y:0,seed:(game.originSeed||game.universe.seed+':home'), id:'S-origin', isOrigin:true};
      const lx = galaxy.ship.x - VIEW_W/2 - PAD, rx = galaxy.ship.x + VIEW_W/2 + PAD;
      const ty = galaxy.ship.y - VIEW_H/2 - PAD, by = galaxy.ship.y + VIEW_H/2 + PAD;
      if (origin.x>=lx && origin.x<=rx && origin.y>=ty && origin.y<=by) out.push(origin);
    } catch(e){}
    return out;
  }

  function findStarById(galaxy, id){
    if (!galaxy) return null;
    const s1 = galaxy.stars && galaxy.stars.find(s=>s.id===id);
    if (s1) return s1;
    if (galaxy.cells){
      // Try to parse streamed id: S-cx,cy-i
      const m = /^S-(-?\d+,-?\d+)-\d+$/.exec(id||'');
      if (m){
        const key = m[1];
        const [cx, cy] = key.split(',').map(Number);
        const arr = generateGalaxyCell(galaxy, cx, cy);
        const s2 = arr.find(s=>s.id===id);
        if (s2) return s2;
      }
      for (const arr of galaxy.cells.values()){
        const s3 = arr.find(s=>s.id===id);
        if (s3) return s3;
      }
    }
    return null;
  }
// Find a star by its display name (case-insensitive), searching visible cells, persisted stars, and nearby generated cells.
function findStarByName(galaxy, name){
  if (!galaxy || !name) return null;
  var target = String(name).trim().toLowerCase();
  // Search in-view stars first
  try{
    var inView = getStarsInView(galaxy);
    for (var i=0;i<inView.length;i++){
      var ss = inView[i];
      if ((computeStarNameForSystem(ss.seed)||'').toLowerCase()===target) return ss;
    }
  }catch(e){}
  // Search persisted stars set
  try{
    if (Array.isArray(galaxy.stars)){
      for (var j=0;j<galaxy.stars.length;j++){
        var ps = galaxy.stars[j];
        if ((computeStarNameForSystem(ps.seed)||'').toLowerCase()===target) return ps;
      }
    }
  }catch(e){}
  // Search a small neighborhood of cells around ship
  try{
    var CELL=1200, RAD=2;
    var cx0 = Math.floor(galaxy.ship.x / CELL), cy0 = Math.floor(galaxy.ship.y / CELL);
    for (var cy=cy0-RAD; cy<=cy0+RAD; cy++){
      for (var cx=cx0-RAD; cx<=cx0+RAD; cx++){
        var arr = generateGalaxyCell(galaxy, cx, cy);
        for (var k=0;k<arr.length;k++){
          var s0 = arr[k];
          if ((computeStarNameForSystem(s0.seed)||'').toLowerCase()===target) return s0;
        }
      }
    }
  }catch(e){}
  return null;
}

function drawGalaxy(galaxy){
    hideInfoButtons();
 clear('#04070d');
    // Draw background stars to match system view
    if (galaxy.bgStars){
  // Twinkling bg stars
  for(const s of galaxy.bgStars){
    const x = VIEW_W/2 + (s.x - galaxy.ship.x*2), y = VIEW_H/2 + (s.y - galaxy.ship.y*2);
    const ix = Math.round(((x % VIEW_W)+VIEW_W)%VIEW_W); const iy = Math.round(((y % VIEW_H)+VIEW_H)%VIEW_H);
    const ph = (((s.x*374761393) ^ (s.y*668265263)) & 1023) / 1023 * Math.PI*2;
    const t = (game._now || performance.now()) * (s.s===2 ? 0.0020 : 0.0015);
    const a = 0.55 + 0.45 * Math.sin(ph + t);
    ctx.globalAlpha = a;
    ctx.fillStyle = (s.s===2 ? '#dff4ff' : '#c7e0ff');
    ctx.fillRect(ix, iy, s.s, s.s);
  }
  ctx.globalAlpha = 1;
    // Travel lines (dotted) connecting first-time visits only, with ≤2 links per star
    try {
      if (window.SETTINGS && SETTINGS.showTravelLines && galaxy && Array.isArray(galaxy.visited) && galaxy.visited.length > 1){
        ctx.save();
        ctx.setLineDash([4, 5]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#64e1ff66';
        // Build chain of first-time visits (preserve original order; drop duplicates just in case)
        var seq = galaxy.visited.slice(0);
        var seen = Object.create(null), chain = [];
        for (var i=0;i<seq.length;i++){ var id = seq[i]; if (id==null) continue; if (seen[id]) continue; seen[id]=true; chain.push(id); }
        // Enforce degree ≤2 per star by skipping edges that would exceed the cap
        var deg = Object.create(null);
        ctx.beginPath();
        for (var i=0;i<chain.length-1;i++){ 
          var aId = chain[i], bId = chain[i+1];
          var da = (deg[aId]|0), db = (deg[bId]|0);
          if (da >= 2 || db >= 2) continue;
          var a = findStarById(galaxy, aId);
          var b = findStarById(galaxy, bId);
          if (!a || !b) continue;
          var ax = Math.round(VIEW_W/2 + (a.x - galaxy.ship.x));
          var ay = Math.round(VIEW_H/2 + (a.y - galaxy.ship.y));
          var bx = Math.round(VIEW_W/2 + (b.x - galaxy.ship.x));
          var by = Math.round(VIEW_H/2 + (b.y - galaxy.ship.y));
          ctx.moveTo(ax, ay);
          ctx.lineTo(bx, by);
          deg[aId] = da + 1;
          deg[bId] = db + 1;
        }
        ctx.stroke();
        ctx.restore();
      }
    } catch(e){}

}
    let nearest=null, best=1e9;
    const __stars = getStarsInView(galaxy);
    __stars.forEach(s=>{ const __ph = ((Math.abs(hashCode(s.id||s.seed||'S'))%1024)/1024)*Math.PI*2; const __t = (game._now||performance.now())*0.002; const __pulse = 0.75 + 0.25*Math.sin(__ph + __t); ctx.save(); ctx.globalAlpha = __pulse; const x = VIEW_W/2 + (s.x - galaxy.ship.x), y = VIEW_H/2 + (s.y - galaxy.ship.y); if (x<-10||x>VIEW_W+10||y<-10||y>VIEW_H+10) return; const __r = seededRandom('sys:'+s.seed); const __cols=['#ff6a4b','#ffd26a','#9ad1ff','#ffb665','#fff8f0']; const __sz=4; const __rad=__sz; const __col = __cols[(__r()*__cols.length)|0]; const __x=Math.round(x), __y=Math.round(y); const __rr=parseInt(__col.slice(1,3),16), __gg=parseInt(__col.slice(3,5),16), __bb=parseInt(__col.slice(5,7),16); ctx.save(); ctx.globalCompositeOperation='lighter'; const __g=ctx.createRadialGradient(__x,__y,0,__x,__y,__rad*2.1); __g.addColorStop(0, `rgba(${__rr},${__gg},${__bb},0.95)`); __g.addColorStop(1, `rgba(${__rr},${__gg},${__bb},0.0)`); ctx.fillStyle=__g; ctx.beginPath(); ctx.arc(__x,__y,__rad*2.1,0,Math.PI*2); ctx.fill(); ctx.globalCompositeOperation='source-over'; ctx.fillStyle=`rgb(${__rr},${__gg},${__bb})`; ctx.beginPath(); ctx.arc(__x,__y,__rad,0,Math.PI*2); ctx.fill(); ctx.restore();const isSel = game.selected && game.selected.type==='star' && game.selected.ref.id===s.id; const d = Math.hypot(x - VIEW_W/2, y - VIEW_H/2); if (d<best){ best=d; nearest={s,x,y}; }
      if (isSel || d < 10){ ctx.strokeStyle = isSel ? '#64e1ff' : '#5effa1'; ctx.lineWidth = 2; ctx.strokeRect(Math.round(x - (14/2)), Math.round(y - (14/2)), 14, 14); }
      if (isSel) { var __d = Math.round(Math.hypot(s.x - galaxy.ship.x, s.y - galaxy.ship.y)); var __nm = computeStarNameForSystem(s.seed); var __lbl = __nm + (s.isOrigin ? ', Origin, ' : ', ') + __d; drawLabel(__lbl, x+2, y-10); } ctx.restore(); });
    if (!game.selected && nearest){ var __d2 = Math.round(Math.hypot(nearest.s.x - galaxy.ship.x, nearest.s.y - galaxy.ship.y)); var __nm2 = computeStarNameForSystem(nearest.s.seed); var __lbl2 = __nm2 + (nearest.s.isOrigin ? ', Origin, ' : ', ') + __d2; drawLabel(__lbl2, nearest.x+2, nearest.y-10); }
    
    // Hyperspace star aura overlay (vibrant glow, independent of bg twinkle)
    (function(){
      try{
        const __ss = getStarsInView(galaxy);
        for (let i=0;i<__ss.length;i++){
          const s = __ss[i];
          const x = VIEW_W/2 + (s.x - galaxy.ship.x);
          const y = VIEW_H/2 + (s.y - galaxy.ship.y);
          const baseR = s.isOrigin ? 9 : 7;
          const now = (game._now || performance.now());
          const phase = ((((s.x*374761393) ^ (s.y*668265263)) & 1023) / 1023) * Math.PI*2;
          const pulse = 0.85 + 0.35 * Math.sin(now*0.003 + phase);
          const R = Math.max(3, Math.round(baseR * pulse));
          const gx = Math.round(x), gy = Math.round(y);
          ctx.save(); ctx.globalCompositeOperation='lighter';
          const g = ctx.createRadialGradient(gx, gy, Math.max(1, R*0.6), gx, gy, R*3.0);
          g.addColorStop(0.00, 'rgba(120,190,255,0.28)');
          g.addColorStop(0.50, 'rgba(120,190,255,0.14)');
          g.addColorStop(1.00, 'rgba(120,190,255,0.00)');
          ctx.fillStyle = g; ctx.beginPath(); ctx.arc(gx, gy, R*3.0, 0, Math.PI*2); ctx.fill();
          ctx.restore();
        }
      }catch(e){}
    })();
    ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';

    // v0.0.74: static high‑quality glow using cached sprites (no animation, low cost)
    try{
      // Cache of pre-rendered glow sprites per color
      if (!window.__glowCache) window.__glowCache = {};
      const cache = window.__glowCache;
      function getGlowSprite(hex){
        if (cache[hex]) return cache[hex];
        const size = 64;
        const off = document.createElement('canvas'); off.width=size; off.height=size;
        const g = off.getContext('2d', {alpha:true});
        const cx=size/2, cy=size/2, r=size/2;
        const grad = g.createRadialGradient(cx,cy, 0, cx,cy, r);
        // soft, layered falloff
        grad.addColorStop(0.00, rgbaFromHex(hex, 0.85));
        grad.addColorStop(0.35, rgbaFromHex(hex, 0.20));
        grad.addColorStop(0.75, rgbaFromHex(hex, 0.05));
        grad.addColorStop(1.00, rgbaFromHex(hex, 0.00));
        g.fillStyle = grad; g.fillRect(0,0,size,size);
        // crisp core sparkle
        g.globalCompositeOperation='lighter';
        g.fillStyle = rgbaFromHex('#ffffff', 0.15);
        g.beginPath(); g.arc(cx,cy, 1.5, 0, Math.PI*2); g.fill();
        cache[hex]=off; return off;
      }

      const __ss = getStarsInView(galaxy) || [];
      // Sort by distance; draw a capped number of glows for perf
      const items = [];
      for (let i=0;i<__ss.length;i++){
        const s = __ss[i];
        const x = VIEW_W/2 + (s.x - galaxy.ship.x);
        const y = VIEW_H/2 + (s.y - galaxy.ship.y);
        const d = Math.hypot(x - VIEW_W/2, y - VIEW_H/2);
        items.push({s,x,y,d});
      }
      items.sort((a,b)=>a.d-b.d);
      const MAX_GLOW = 18;
      const n = Math.min(MAX_GLOW, items.length);
      for (let i=0;i<n;i++){
        const it = items[i];
        const col = computeStarColorForSeed(it.s.seed||it.s.id||galaxy.seed);
        const spr = getGlowSprite(col);
        const rCore = it.s.isOrigin ? 9 : 7;
        const destR = rCore * 2.6; // visual halo size
        const dest = destR * 2;
        ctx.save();
        ctx.globalCompositeOperation='lighter';
        ctx.globalAlpha = 1;
        ctx.drawImage(spr, Math.round(it.x - dest/2), Math.round(it.y - dest/2), dest, dest);
        ctx.restore();
      }
    }catch(e){}
    ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
drawShip(VIEW_W/2, VIEW_H/2);
  }

  function setLocLabel(system, world){ let label='—'; if (game.state===STATE.HYPER) label='Hyperspace'; else if (system) label = (function(){ try{ if(!world) return system.name; if (world._kind==='Moon'){ var host=(system.planets||[]).find(p=>(p.moons||[]).some(m=>m.seed===world.seed)); return system.name + ' • ' + (host?host.name:'?') + ' • ' + world.name; } var maybeHost=(system.planets||[]).find(p=>(p.moons||[]).some(m=>m.seed===world.seed)); if (maybeHost && maybeHost.seed!==world.seed){ return system.name + ' • ' + maybeHost.name + ' • ' + world.name; } return system.name + ' • ' + world.name; }catch(e){ return world? (system.name+' • '+world.name) : system.name; }})(); try{buildLocHTML(label);}catch(e){ try{ buildLocHTML(label); }catch(e){ document.getElementById('locLabel').textContent = label; } } }
  function updateCoordsUI(){ let x=0,y=0,z=game.zLayer; const coordsEl = document.getElementById('coords'); if (coordsEl && typeof SETTINGS !== 'undefined') coordsEl.style.display = SETTINGS.showCoords ? '' : 'none'; if (game.state===STATE.GROUND){ x = Math.round((game.player.x - game.displayOrigin.x)/TILE); y = Math.round((game.player.y - game.displayOrigin.y)/TILE); z = 0; }
    else if (game.state===STATE.SPACE){ x = Math.round(-game.camera.x/8); y = Math.round(-game.camera.y/8); z = 1; } else if (game.state===STATE.HYPER){
x = Math.round(game.galaxy.ship.x/10); y = Math.round(game.galaxy.ship.y/10); z = 2; } document.getElementById('coords').textContent = `X: ${x}  Y: ${y}  Z: ${z}`; }

  function placePlayerOnSurface(planet){ const world = generateSurface(planet.seed); game.world = world; game.player.x = world.W*world.tile*0.5; game.player.y = world.H*world.tile*0.5; game.displayOrigin.x = game.player.x; game.displayOrigin.y = game.player.y; game.camera.x = game.player.x; game.camera.y = game.player.y; game.zLayer = 0; game.ship = { x: game.player.x + 24, y: game.player.y, target:null }; game.lastPlanet = planet; setLocLabel(game.system, planet); toast(`Use the joystick to move. Tap to select.`); }

  /* ---------- Animations ---------- */
  function drawThrustFlame(cx, cy, t){ const flick = Math.sin(t*0.003)*4; actx.fillStyle = 'rgba(100,200,255,.5)'; actx.fillRect(cx-2, cy+6, 4, 14+flick); actx.fillStyle = 'rgba(255,180,120,.6)'; actx.fillRect(cx-1, cy+6, 2, 12+flick); }
  function startLaunchAnim(){ game.anim = { kind:'launch', t:0 }; }
  function startLandAnim(targetPlanet){ game.hideShipDuringLand = true; game.anim = { kind:'land', t:0, planet: targetPlanet }; }
  function renderAnimOverlay(dt){ if (!game.anim) { actx.clearRect(0,0,animCanvas.width,animCanvas.height); return; } game.anim.t += dt; const t = game.anim.t; actx.clearRect(0,0,animCanvas.width,animCanvas.height);
    if (game.anim.kind==='launch'){ const p = Math.min(1, t/800); const cx = VIEW_W/2, cy = VIEW_H/2 + (1-p)*10; drawThrustFlame(cx, cy, t); actx.fillStyle = `rgba(0,0,0,${p*0.6})`; actx.fillRect(0,0,VIEW_W,VIEW_H);
      if (t>900 && game.state===STATE.GROUND){ game.state=STATE.SPACE; game.zLayer=1; if(!game.system) game.system=generateSystem(game.universe.seed+':home'); if (game.lastPlanet){ let lp=game.lastPlanet; let parent=null; for (const p of game.system.planets){ if (p.seed===lp.seed) { parent=null; break; } if (p.moons && p.moons.some(m=>m.seed===lp.seed)) { parent=p; break; } } if (parent){ const px=Math.cos(parent.theta)*parent.orbit; const py=Math.sin(parent.theta)*parent.orbit; game.camera.x = px + Math.cos(lp.theta)*lp.orbit; game.camera.y = py + Math.sin(lp.theta)*lp.orbit; } else { game.camera.x = Math.cos(lp.theta)*lp.orbit; game.camera.y = Math.sin(lp.theta)*lp.orbit; } } else { game.camera.x=0; game.camera.y=0; } game.spaceTarget=null; game.followSelectionId = null; game.followSelectionId = null; game.followSelectionId=null; setLocLabel(game.system, null); }
      if (t>1400){ game.anim=null; game.hideShipDuringLand=false; }
    }
    else if (game.anim.kind==='land'){ const p = Math.min(1, t/900); const r = (20*(1-p) + Math.max(VIEW_W,VIEW_H)*p); const grad = actx.createRadialGradient(VIEW_W/2, VIEW_H/2, 10, VIEW_W/2, VIEW_H/2, r);
      grad.addColorStop(0, 'rgba(120,200,255,.35)'); grad.addColorStop(0.6, 'rgba(50,80,140,.55)'); grad.addColorStop(1, 'rgba(0,0,0,.1)'); actx.fillStyle = grad; actx.fillRect(0,0,VIEW_W,VIEW_H);  try {     const prog = Math.min(1, t/950);    const scale = Math.max(0.35, 1 - 0.6*prog);    actx.save();    actx.translate(VIEW_W/2, VIEW_H/2);    actx.scale(scale, scale);    actx.drawImage(shipSprite, Math.round(-12), Math.round(-7));    actx.restore();  } catch(e){}
  
      if (t>950 && game.state===STATE.SPACE){ placePlayerOnSurface(game.anim.planet); game.state = STATE.GROUND; game.zLayer = 0; setJoystickVisible(true); }
      if (t>1400){ game.anim=null; game.hideShipDuringLand=false; }
    }
  }

  function launchFromSurface(){ toast('Launching...'); startLaunchAnim(); }
  function landFromSpace(targetSel){ const targetBody = targetSel.ref; startLandAnim(targetBody); }

  function tryInteract(){ if (game.state===STATE.GROUND) { const dx = game.ship.x - game.player.x, dy = game.ship.y - game.player.y, d2 = dx*dx + dy*dy; if (d2 < 36*36) launchFromSurface(); else toast('Move closer to the ship.'); }
    else if (game.state===STATE.SPACE) { if (game.selected && (game.selected.type==='planet'||game.selected.type==='moon')) { landFromSpace(game.selected); } else { toast('Select a planet/moon, then Land.'); } } }

  function getBodyScreenPos(sel){ if (game.state!==STATE.SPACE) return null; const p = sel.ref; let x,y; if (sel.type==='planet'){ x = VIEW_W/2 + Math.cos(p.theta)*p.orbit - game.camera.x; y = VIEW_H/2 + Math.sin(p.theta)*p.orbit - game.camera.y; }
    else if (sel.type==='moon'){ const px = VIEW_W/2 + Math.cos(sel.parent.theta)*sel.parent.orbit - game.camera.x; const py = VIEW_H/2 + Math.sin(sel.parent.theta)*sel.parent.orbit - game.camera.y; x = px + Math.cos(p.theta)*p.orbit; y = py + Math.sin(p.theta)*p.orbit; }
    else if (sel.type==='star'){ x = VIEW_W/2 - game.camera.x; y = VIEW_H/2 - game.camera.y; }
    return {x,y}; }

  const actionBtn = document.getElementById('actionMain');
  actionBtn.setAttribute('aria-label','Primary action');
  const renameBtn = document.getElementById('renameBtn');
  
  renameBtn.setAttribute('aria-label','Rename selection');
function renameObject(obj){
    const current = obj.name || '';
    const nv = prompt('Rename:', current);
    if (nv !== null) {
      const newName = nv.trim();
      if (newName.length) { 
        obj.name = newName; 
        if (obj.seed){
          // Always save the name against the system seed (used in hyperspace)
          setCustomName(obj.seed, newName);
          // If this is a star object from hyperspace (id like 'S-...'), also mirror to the star-seed used inside systems
          if (obj.id && (''+obj.id).startsWith('S-')) { 
            setCustomName(obj.seed+':star', newName); 
          }
        }
        setLocLabel(game.system, null); 
        refreshActionUI(); 
      }
    }
  }
  function refreshActionUI(){
  // Info button handlers
  if (infoBtnBody) infoBtnBody.onclick = ()=>{
    if (!game || !game.selected || !(game.selected.type==='planet'||game.selected.type==='moon')) return;
    const e = game.selected.ref;
    showInfoFor(e, e.name || 'Info');
  };
  if (infoBtnStar) infoBtnStar.onclick = ()=>{
    if (!game || !game.system || !game.system.star) return;
    showInfoFor(game.system.star, game.system.star.name || 'Star');
  };
 renameBtn.style.display = 'none';
        if (!game.selected){ if (game.state===STATE.GROUND) { actionBtn.textContent = 'Interact'; actionBtn.onclick = () => tryInteract(); } else if (game.state===STATE.SPACE) { actionBtn.textContent = 'Interact'; actionBtn.onclick = () => tryInteract(); } else actionBtn.textContent='—'; return; }
    if (game.state===STATE.SPACE && (game.selected.type==='planet'||game.selected.type==='moon')){
      const pos = getBodyScreenPos(game.selected);
      const R = (game.selected.ref && game.selected.ref.R) ? game.selected.ref.R : 10;
      const atCenter = pos ? (Math.hypot(pos.x - VIEW_W/2, pos.y - VIEW_H/2) < 1) : false;
      if (atCenter) { 
        actionBtn.textContent = `Land on ${game.selected.ref.name}`; 
        actionBtn.onclick = () => landFromSpace(game.selected); 
      } else { 
        actionBtn.textContent = 'Go to'; 
        actionBtn.onclick = () => { if (pos) { game._noFollowUntil = 0; game.spaceTarget = { type:'body', sel: game.selected }; } }; 
      }
} else if (game.state===STATE.HYPER && game.selected.type==='star'){
      actionBtn.textContent = 'Go to'; actionBtn.onclick = () => { game.galaxy.target = game.selected.ref; game.galaxy.freeTarget = null; };
      
    } else { actionBtn.textContent = 'Interact'; actionBtn.onclick = () => tryInteract(); }
  }

  const canvasRectToLocal = (e)=>{ const rect = canvas.getBoundingClientRect(); return { x: (e.clientX - rect.left), y: (e.clientY - rect.top) }; };

  canvas.addEventListener('pointerdown', (e) => {
    const {x:sx,y:sy} = canvasRectToLocal(e);
    if (game.state === STATE.GROUND) {
      const wx = game.camera.x - VIEW_W/2 + sx; const wy = game.camera.y - VIEW_H/2 + sy; const tx = Math.floor(wx / TILE); const ty = Math.floor(wy / TILE);
      game.highlight = {tx, ty}; game.selected = { type:'tile', ref:{tx,ty} }; refreshActionUI();
    } else if (game.state === STATE.SPACE) {
      let best=null, bestD=1e9; game.system.planets.forEach(p=>{ const px = VIEW_W/2 + Math.cos(p.theta)*p.orbit - game.camera.x; const py = VIEW_H/2 + Math.sin(p.theta)*p.orbit - game.camera.y; const dp = Math.hypot(px - sx, py - sy) - p.R; if (dp < bestD) { best = { type:'planet', ref:p, dist:dp }; bestD = dp; } p.moons.forEach(m=>{ const mx=px+Math.cos(m.theta)*m.orbit, my=py+Math.sin(m.theta)*m.orbit; const dm=Math.hypot(mx - sx, my - sy) - m.R; if(dm < bestD) { best={ type:'moon', ref:m, parent:p, dist:dm }; bestD=dm; } }); });
      if (best && bestD < 24) { game.selected = best; refreshActionUI(); } else { game.selected = null; refreshActionUI(); }
    } else if (game.state === STATE.HYPER) { const __loc = getStarsInView(game.galaxy); const PAD=200, lx=game.galaxy.ship.x - VIEW_W/2 - PAD, rx=game.galaxy.ship.x + VIEW_W/2 + PAD, ty=game.galaxy.ship.y - VIEW_H/2 - PAD, by=game.galaxy.ship.y + VIEW_H/2 + PAD; const __static = (game.galaxy.stars||[]).filter(ss=> ss.isOrigin && ss.x>=lx&&ss.x<=rx&&ss.y>=ty&&ss.y<=by); const __cand = __loc.concat(__static);
      let found = null, bestD = 14; __cand.forEach(s => { const sx2 = VIEW_W/2 + (s.x - game.galaxy.ship.x); const sy2 = VIEW_H/2 + (s.y - game.galaxy.ship.y); const d = Math.hypot(sx - sx2, sy - sy2); if (d < bestD) { bestD = d; found = s; } });
      if (found) { game.selected = { type:'star', ref:found }; refreshActionUI(); document.getElementById('enterBtn').style.display='none'; } else { game.selected = null; refreshActionUI(); document.getElementById('enterBtn').style.display='none'; }
    }
  });

  /* Joystick */
  const joy = document.getElementById('joystick');
  const stick = document.getElementById('stick');
  let __joyShown = false;
function setJoystickVisible(show){
  if (show) {
    if (!__joyShown) { joy.style.display = 'block'; if (window.centerStick) centerStick(); __joyShown = true; }
    // already visible: don't recenter while dragging
  } else {
    if (__joyShown) { joy.style.display = 'none'; __joyShown = false; }
  }
}
  function onJoyStart(ev){ if (joy.setPointerCapture && ev.pointerId!==undefined) try{joy.setPointerCapture(ev.pointerId);}catch(e){}  ev.preventDefault(); game.stick.active = true; updateStick(ev); }
  function onJoyEnd(ev){ if (joy.releasePointerCapture && ev.pointerId!==undefined) try{joy.releasePointerCapture(ev.pointerId);}catch(e){}  ev.preventDefault(); game.stick.active=false; const cx=(joy.clientWidth - stick.clientWidth)/2; const cy=(joy.clientHeight - stick.clientHeight)/2; stick.style.setProperty('--dx','0px'); stick.style.setProperty('--dy','0px'); game.stick.dx=0; game.stick.dy=0; }
stick.style.left='50%'; stick.style.top='50%';
  function updateStick(ev){
  ev.preventDefault && ev.preventDefault();
  const rect = joy.getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top  + rect.height/2;
  const px = (ev.touches ? ev.touches[0].clientX : ('clientX' in ev ? ev.clientX : cx));
  const py = (ev.touches ? ev.touches[0].clientY : ('clientY' in ev ? ev.clientY : cy));
  const x = px - cx;
  const y = py - cy;
  const max = Math.min(joy.clientWidth, joy.clientHeight)/2 - (stick.clientWidth/2) - 1;
  const d = Math.hypot(x,y);
  const nx = d>0 ? x/d : 0, ny = d>0 ? y/d : 0;
  const clamped = Math.min(d, max);
  const centerX = joy.clientWidth/2;
  const centerY = joy.clientHeight/2;
  stick.style.setProperty('--dx', String(nx*clamped) + 'px');
  stick.style.setProperty('--dy', String(ny*clamped) + 'px');
  game.stick.dx = nx * (d>0 ? Math.min(d/max, 1) : 0);
  game.stick.dy = ny * (d>0 ? Math.min(d/max, 1) : 0);
}
['pointerdown'].forEach(t=> joy.addEventListener(t, onJoyStart, {passive:false}));
  ['pointerdown'].forEach(t=> stick.addEventListener(t, onJoyStart, {passive:false}));
['pointerup','pointercancel','mouseleave'].forEach(t=> joy.addEventListener(t, onJoyEnd));
  ['pointerup','pointercancel','mouseleave'].forEach(t=> stick.addEventListener(t, onJoyEnd));
['pointermove'].forEach(t=> joy.addEventListener(t, (e)=>{ if(game.stick.active) updateStick(e); }, {passive:false}));

  // Global fallback to ensure the stick always recenters on release (iOS/Safari edge-cases)
  ;['pointerup','pointercancel','touchend'].forEach(t=> {
    window.addEventListener(t, (e)=>{
      try {
        if (game && game.stick && game.stick.active) onJoyEnd(e);
      } catch(_){}
    }, {capture:true, passive:false});
  });
['pointermove'].forEach(t=> stick.addEventListener(t, (e)=>{ if(game.stick.active) updateStick(e); }, {passive:false}));
['pointermove'].forEach(t=> window.addEventListener(t, (e)=>{ if(game.stick.active) updateStick(e); }, {passive:false}));

  
  /* Keyboard controls (WASD/Arrow + E/Enter) */
  const keyDir = {x:0, y:0};
  const keyMap = { 'ArrowLeft':[-1,0], 'ArrowRight':[1,0], 'ArrowUp':[0,-1], 'ArrowDown':[0,1],
                   'a':[-1,0], 'd':[1,0], 'w':[0,-1], 's':[0,1], 'A':[-1,0], 'D':[1,0], 'W':[0,-1], 'S':[0,1] };
  window.addEventListener('keydown', (e)=>{
    if (keyMap[e.key]) {
      const [dx,dy] = keyMap[e.key];
      keyDir.x = Math.max(-1, Math.min(1, keyDir.x + dx));
      keyDir.y = Math.max(-1, Math.min(1, keyDir.y + dy));
      game.stick.active = true;
      game.stick.dx = keyDir.x;
      game.stick.dy = keyDir.y; game._noFollowUntil = Date.now() + 1800; game.followSelectionId = null;
      e.preventDefault();
    } else if (e.key === 'Enter' || e.key === 'e' || e.key === 'E') {
      if (typeof actionBtn?.onclick === 'function') actionBtn.onclick();
    }
  });
  window.addEventListener('keyup', (e)=>{
    if (keyMap[e.key]){
      const [dx,dy] = keyMap[e.key];
      keyDir.x = Math.max(-1, Math.min(1, keyDir.x - dx));
      keyDir.y = Math.max(-1, Math.min(1, keyDir.y - dy));
      if (keyDir.x===0 && keyDir.y===0){ game.stick.active=false; game.stick.dx=0; game.stick.dy=0; }
      e.preventDefault();
    }
  });
/* Start menu & inventory overlays */
  const startOverlay = document.getElementById('startOverlay');
  const savesList = document.getElementById('savesList');
  const inputName = document.getElementById('universeName');
  const inputSeed = document.getElementById('seed');
  const btnCreate = document.getElementById('createStart');
  const btnRand = document.getElementById('randSeed');
  const invOverlay = document.getElementById('invOverlay');
  const settingsBtn = document.getElementById('settingsBtn');
  const settingsOverlay = document.getElementById('settingsOverlay');
  const closeSettings = document.getElementById('closeSettings');
  /* === Units setting (Miles/Kilometers) === */
  const UNITS_KEY = 'spacebitz:units';
  function loadUnits(){ try{ const v=localStorage.getItem(UNITS_KEY); return (v==='km'||v==='mi') ? v : 'mi'; }catch(e){ return 'mi'; } }
  function saveUnits(u){ try{ localStorage.setItem(UNITS_KEY, u); }catch(e){} }
  function milesToKm(mi){ return mi * 1.60934; }
  let units = loadUnits();
  const unitsSelect = document.getElementById('unitsSelect');
  if (unitsSelect) { unitsSelect.value = units; unitsSelect.addEventListener('change', ()=>{ units = unitsSelect.value; saveUnits(units); }); }

  /* === Info overlay & buttons === */
  function hideInfoButtons(){ 
    if (infoBtnStar) infoBtnStar.style.display='none'; 
    if (infoBtnBody) infoBtnBody.style.display='none'; 
  }

  const infoBtnStar = document.getElementById('infoBtnStar');
  const infoBtnBody = document.getElementById('infoBtnBody');
  const infoOverlay = document.getElementById('infoOverlay');
  const infoTitle = document.getElementById('infoTitle');
  const infoDetails = document.getElementById('infoDetails');
  const closeInfo = document.getElementById('closeInfo');
  function closeInfoOverlay(){ infoOverlay.style.display='none'; if (game.state!==STATE.SPACE) hideInfoButtons(); }
  if (closeInfo) closeInfo.addEventListener('click', closeInfoOverlay);
  
  function fmtDiam(mi){
    if (typeof mi !== 'number' || !isFinite(mi)) return '—';
    const roundedMi = Math.round(mi); // nearest mile
    if (units === 'km') return Math.round(milesToKm(roundedMi)).toLocaleString() + ' km';
    return roundedMi.toLocaleString() + ' mi';
  }

  function showInfoFor(entity, label){
    infoTitle.textContent = label || (entity?.name || 'Info');
    let diamMi = entity?.diamMi;
    let bodyType = entity?._kind || '';
    // Only planets/moons have a meaningful diameter right now.
    let parts = [];
    if (bodyType) parts.push('<div><strong>Type:</strong> ' + bodyType + '</div>');
    if (typeof diamMi === 'number') parts.push('<div><strong>Diameter:</strong> ' + fmtDiam(diamMi) + '</div>');
    else parts.push('<div><strong>Diameter:</strong> —</div>');
    infoDetails.innerHTML = parts.join('');
    infoOverlay.style.display='flex';
  }
  
  // ===== Music playback: soundtrack-1 (solo, slow & soft, default ON) =====
  const SOUNDTRACK_ID = 'soundtrack-1';
  const MUSIC_KEY = 'spacebitz:musicEnabled';
  function loadMusicEnabled(){ try{ const v=localStorage.getItem(MUSIC_KEY); return v===null ? true : (v==='true'); }catch(e){ return true; } }
  function saveMusicEnabled(v){ try{ localStorage.setItem(MUSIC_KEY, String(!!v)); }catch(e){} }
  const musicToggle = document.getElementById('musicToggle');
  let musicEnabled = loadMusicEnabled();
  if (musicToggle) musicToggle.checked = musicEnabled;

  const MELODY_SEQ = [60, 64, 67, 64, 62, 67, 59, 67, 57, 60, 64, 60, 57, 60, 65, 60, 60, 64, 67, 64, 62, 67, 59, 67, 57, 60, 64, 60, 57, 60, 65, 60, 60, 64, 67, 64, 62, 67, 59, 67, 57, 60, 64, 60, 57, 60, 65, 60, 60, 64, 67, 64, 62, 67, 59, 67, 57, 60, 64, 60, 57, 60, 65, 60, 60, 64, 67, 64, 62, 67, 59, 67, 57, 60, 64, 60, 57, 60, 65, 60, 60, 64, 67, 64, 62, 67, 59, 67, 57, 60, 64, 60, 57, 60, 65, 60, 137, 137, 137, 137, 137];   // MIDI notes or null per 8th
  const TEMPO_BPM = 48; // very slow nostalgic pace
  const MASTER_GAIN = 0.14; // softer overall

  const Music = (()=>{
    let ac=null, master=null, timer=null, anchorTime=0, stepIdx=0, playing=false;
    const lookahead = 0.10;
    const scheduleAhead = 0.40;

    function midiToHz(n){ return 440*Math.pow(2,(n-69)/12); }
    function ensure(){ 
      if(!ac){ 
        ac=new (window.AudioContext||window.webkitAudioContext)(); 
        master=ac.createGain(); master.gain.value=MASTER_GAIN; master.connect(ac.destination);
        ac.onstatechange = () => { if (ac.state==='suspended' && playing) { ac.resume().catch(()=>{}); } };
      } 
      return ac; 
    }

    function scheduleNote(note, t, stepDur){
      if (note==null) return;
      const c=ensure();
      const o=c.createOscillator(); o.type='sine'; o.frequency.value=midiToHz(note);
      const lfo=c.createOscillator(); lfo.type='sine'; lfo.frequency.value=4.5;
      const lfoGain=c.createGain(); lfoGain.gain.value=4.0; // cents
      lfo.connect(lfoGain); lfoGain.connect(o.detune);

      const lp = c.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=1100; lp.Q.value=0.4;

      const g=c.createGain();
      const a=0.012, d=0.10, sus=0.60, rel=0.10;
      const dur = stepDur * 0.99;
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(1.0, t+a);
      g.gain.linearRampToValueAtTime(sus, t+a+d);
      g.gain.linearRampToValueAtTime(0.0, t+dur+rel);

      o.connect(g); g.connect(lp); lp.connect(master);
      o.start(t); lfo.start(t);
      o.stop(t+dur+rel+0.02); lfo.stop(t+dur+rel+0.02);
    }

    function tick(){
      const c=ensure(); 
      const stepDur = (60/TEMPO_BPM)/2; // 8th note
      while (true) {
        const nextTime = anchorTime + stepIdx * stepDur;
        if (nextTime > c.currentTime + scheduleAhead) break;
        const n = MELODY_SEQ[stepIdx % MELODY_SEQ.length];
        scheduleNote(n, nextTime, stepDur);
        stepIdx++;
      }
      timer = setTimeout(tick, lookahead*1000);
    }

    async function start(){ 
      if(playing) return; 
      const c=ensure(); 
      if(c.state==='suspended'){ try{await c.resume()}catch(_ ){} } 
      playing=true; 
      stepIdx=0; 
      anchorTime=c.currentTime+0.05; 
      tick(); 
    }
    function stop(){ 
      playing=false; 
      if(timer){ clearTimeout(timer); timer=null; } 
      try{ ac && ac.suspend(); }catch(e){} 
    }
    return { start, stop };
  })();

  function applyMusic(){ if(musicEnabled) Music.start(); else Music.stop(); }
  if (typeof startUniverse==='function'){ const _su=startUniverse; startUniverse=function(u){ _su(u); setTimeout(applyMusic,1000); }; }
  
  // Start music ~1s after startup (if allowed and enabled)
  setTimeout(()=>{ try{ if (musicEnabled) Music.start(); }catch(e){} }, 1000);
const _resume=()=>{ try{ if (musicEnabled) Music.start(); else Music.stop(); }catch(e){} };
  document.addEventListener('pointerdown', _resume, true); 
  document.addEventListener('keydown', _resume, true);
  document.addEventListener('visibilitychange', ()=>{ if (!document.hidden) _resume(); });
  if (musicToggle) musicToggle.addEventListener('change', ()=>{ musicEnabled=!!musicToggle.checked; saveMusicEnabled(musicEnabled); applyMusic(); });

  // Joystick position settings (persisted)
  const JOY_KEY = 'spacebitz:joycfg';
  function loadJoyCfg(){ try{ return JSON.parse(localStorage.getItem(JOY_KEY)||'{}'); }catch(e){ return {}; } }
  function saveJoyCfg(cfg){ localStorage.setItem(JOY_KEY, JSON.stringify(cfg)); }
  function applyJoyCfg(cfg){
    const x = (cfg.xPerc!=null? cfg.xPerc : 50);
    const y = (cfg.yOffsetPx!=null? cfg.yOffsetPx : 28);
    document.documentElement.style.setProperty('--joy-left', String(x));
    document.documentElement.style.setProperty('--joy-v-offset', y+'px');
  }
  const joyCfg = Object.assign({xPerc:50, yOffsetPx:125}, loadJoyCfg());
  applyJoyCfg(joyCfg);
  const joyX = document.getElementById('joyX'); const joyY = document.getElementById('joyY');
  const joyXVal = document.getElementById('joyXVal'); const joyYVal = document.getElementById('joyYVal');
  if (joyX && joyY){
    // initialize UI from cfg whenever settings opens
    settingsBtn?.addEventListener('click', ()=>{ joyX.value = String(joyCfg.xPerc); joyY.value = String(joyCfg.yOffsetPx); joyXVal.textContent = joyX.value+'%'; joyYVal.textContent = joyY.value+'px'; });
    joyX.addEventListener('input', ()=>{ joyCfg.xPerc = Math.max(0, Math.min(100, parseInt(joyX.value||'50',10))); joyXVal.textContent = joyX.value+'%'; applyJoyCfg(joyCfg); saveJoyCfg(joyCfg); });
    joyY.addEventListener('input', ()=>{ joyCfg.yOffsetPx = Math.max(0, Math.min(200, parseInt(joyY.value||'28',10))); joyYVal.textContent = joyY.value+'px'; applyJoyCfg(joyCfg); saveJoyCfg(joyCfg); });
  }

  if(settingsBtn){ settingsBtn.addEventListener('click', ()=>{ settingsOverlay.style.display='grid'; }); }
  if(closeSettings){ closeSettings.addEventListener('click', ()=>{ settingsOverlay.style.display='none'; }); }
  // --- injected: Save & Quit + third-hop render fix ---
  (function(){
    const btn = document.getElementById('saveQuitBtn');
    if (btn){
      btn.addEventListener('click', ()=>{
        try {
          const snapshot = (function collectQuickSaveSnapshot(){
            const coordsEl = document.getElementById('coords');
            const locEl = document.getElementById('locLabel');
            const out = {
              ts: Date.now(),
              version: (typeof VERSION!=='undefined'? VERSION : null),
              state: game?.state || null,
              currentStarId: game?.currentStarId || null,
              universeId: game?.universe?.id || null,
              universeName: game?.universe?.name || null,
              systemSeed: game?.system?.seed || null,
              systemName: game?.system?.name || null,
              worldSeed: game?.world?.seed || null,
              worldName: game?.world?.name || null,
              camera: game?.camera ? {x:game.camera.x, y:game.camera.y} : null,
              player: game?.player ? {x:game.player.x, y:game.player.y, dir:game.player.dir} : null,
              galaxyShip: game?.galaxy?.ship ? {x:game.galaxy.ship.x, y:game.galaxy.ship.y} : null,
              galaxyVisited: (game?.galaxy && Array.isArray(game.galaxy.visited)) ? game.galaxy.visited.slice() : ((game?.universe?.quickSave && Array.isArray(game.universe.quickSave.galaxyVisited)) ? game.universe.quickSave.galaxyVisited.slice() : []),
              coordsText: coordsEl ? coordsEl.textContent : '',
              locLabel: locEl ? locEl.textContent : ''
            };
            return out;
          })();
          // Enrich snapshot with robust fallbacks for identity/state
          try {
            if (!snapshot.worldSeed) {
              snapshot.worldSeed = (game?.world?.seed) || (game?.lastPlanet?.seed) ||
                ((game?.selected && (game.selected.type==='planet' || game.selected.type==='moon')) ? game.selected.ref.seed : null);
            }
            if (!snapshot.systemSeed) {
              snapshot.systemSeed = game?.system?.seed || (game?.universe?.seed ? (game.universe.seed+':home') : null);
            }
            if (!snapshot.state) { snapshot.state = game?.state || null; }
            if (!snapshot.currentStarId) { snapshot.currentStarId = game?.currentStarId || null; }
          } catch(e) {}

          if (game?.universe){
            const u = game.universe;
            u.quickSave = snapshot;
            u.lastPlayedAt = Date.now();
            try {
              const list = loadSaves().map(s=> s.id===u.id ? u : s);
              saveSaves(list);
            } catch(e){
              // fall back to a dedicated quickSave key if unified saves fail
              localStorage.setItem('spacebitz:quickSave', JSON.stringify(snapshot));
            }
          } else {
            localStorage.setItem('spacebitz:quickSave', JSON.stringify(snapshot));
          }
          try{ toast('Saved. Returning to main menu...'); }catch(e){} try{ window.menuStarsActive=true; const ms=document.getElementById('menuStars'); if(ms){ ms.style.display='block'; } if(typeof drawMenuStars==='function'){ drawMenuStars._last = performance.now(); requestAnimationFrame(()=>drawMenuStars(16)); } }catch(e){}
          try{ document.getElementById('settingsOverlay').style.display='none'; }catch(e){}
          try{ try{ if(typeof hideInfoButtons==='function') hideInfoButtons(); }catch(e){} showStart(); }catch(e){ location.reload(); }
        } catch(err){
          console.error('Save & Quit failed', err);
          try{ toast('Save failed'); }catch(e){}
        }
      });
    }
    // Heuristic repair for "third star renders nothing" after multiple hops.
    function repairIfBlank(){
      try{
        // Hyperspace: ensure galaxy is initialized and ship is valid
        if (game?.state === STATE.HYPER){
          if (!game.galaxy || !game.galaxy.ship || Number.isNaN(game.galaxy.ship.x) || !game.galaxy.bgStars){
            game.galaxy = generateGalaxy(game?.universe?.seed || 'default', (game.originSeed || ((game?.universe?.seed) ? (game.universe.seed+':home') : null)), computeStarNameForSystem(game.originSeed || ((game?.universe?.seed) ? (game.universe.seed+':home') : '')));
            const starEntry = (typeof findStarById==='function') ? (findStarById(game.galaxy, game.currentStarId) || (game.galaxy.stars && game.galaxy.stars[0]) || null) : null;
            if (!game.galaxy.ship) game.galaxy.ship = {x:0,y:0};
            if (starEntry){ game.galaxy.ship.x = starEntry.x; game.galaxy.ship.y = starEntry.y - 20; game.selected = { type:'star', ref: starEntry }; }
          }
        }
        // Space: ensure system has bodies
        if (game?.state === STATE.SPACE){
          if (!game.system || !game.system.star || !Array.isArray(game.system.planets) || game.system.planets.length===0){
            const seed = (game.system && game.system.seed) || (game?.universe?.seed + ':home');
            game.system = (seed==='sol' ? generateSolSystem() : generateSystem(seed));
            try{ setLocLabel(game.system, null); }catch(e){}
            // reset camera to a safe position
            game.camera.x = 0; game.camera.y = 0;
          }
        }
      } catch(e){ /* swallow to avoid breaking loop */ }
    }
    // Run the repair periodically (lightweight checks)
    setInterval(repairIfBlank, 600);
  })();
  // --- end injected ---
// --- injected v6: strict validation + ship unhide ---
(function(){
  function validateSystemStrict(){
    try{
      if (!game?.system) return false;
      if (!game.system.star) return false;
      if (!Array.isArray(game.system.planets) || game.system.planets.length===0) return false;
      if (!Array.isArray(game.system.bgStars) || game.system.bgStars.length===0) return false;
      return true;
    }catch(e){ return false; }
  }
  function stabilizeHard(){
    try{
      // Unhide ship if an animation left it hidden
      game.hideShipDuringLand = false;
      if (game.anim && (game.anim.kind==='land' || game.anim.kind==='launch')) game.anim = null;

      if (game.state===STATE.SPACE && !validateSystemStrict()){
        const seed = (game.system && game.system.seed) || (game?.universe?.seed + ':home');
        game.system = (seed==='sol' ? generateSolSystem() : generateSystem(seed));
        setLocLabel(game.system, null);
        if (!isFinite(game.camera?.x) || !isFinite(game.camera?.y)){ game.camera.x=0; game.camera.y=0; }
      }
      if (game.state===STATE.HYPER){
        if (!game.galaxy || !Array.isArray(game.galaxy.bgStars)) {
          game.galaxy = generateGalaxy(game?.universe?.seed || 'default', (game.originSeed || ((game?.universe?.seed) ? (game.universe.seed+':home') : null)), computeStarNameForSystem(game.originSeed || ((game?.universe?.seed) ? (game.universe.seed+':home') : '')));
        }
        if (!game.galaxy.ship) game.galaxy.ship = {x:0,y:0};
        const starEntry = (typeof findStarById==='function') ? (findStarById(game.galaxy, game.currentStarId) || (game.galaxy.stars && game.galaxy.stars[0]) || null) : null;
        if (starEntry && (!isFinite(game.galaxy.ship.x) || !isFinite(game.galaxy.ship.y))) {
          game.galaxy.ship.x = starEntry.x; game.galaxy.ship.y = starEntry.y - 20;
        }
        if (!game.selected && starEntry){ game.selected = { type:'star', ref: starEntry }; }
      }
    }catch(e){}
  }
  // Call after warp/enter, and opportunistically during SPACE render guards
  try {
    const w = document.getElementById('warpBtn');
    if (w) w.addEventListener('click', ()=>{ setTimeout(stabilizeHard, 0); setTimeout(stabilizeHard, 200); });
    const ebtn = document.getElementById('enterBtn');
    if (ebtn) ebtn.addEventListener('click', ()=>{ setTimeout(stabilizeHard, 0); setTimeout(stabilizeHard, 200); });
  } catch(e){}
  window._sb_stabilizeHard = stabilizeHard; // for debugging
})();
// --- end injected v6 ---
// --- injected v7: hard canvas reset helper ---
(function(){
  window._sb_resetCanvasHard = function(){
    try{
      // Recreate the drawing state to drop any rogue clip paths or transforms
      const w = Math.floor(VIEW_W * DPR), h = Math.floor(VIEW_H * DPR);
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      } else {
        // Force a flush by toggling width
        canvas.width = w; canvas.height = h;
      }
      ctx.setTransform(DPR,0,0,DPR,0,0);
      ctx.globalAlpha = 1;
      ctx.globalCompositeOperation = 'source-over';
    }catch(e){}
  };
})();
// --- end injected v7 ---


// --- injected v8: unified state transition helper ---
(function(){
  window.safeTransition = function(nextState){
    try{ if (typeof _sb_resetCanvasHard === 'function') _sb_resetCanvasHard(); }catch(e){}
    try{
      setTimeout(function(){ try{ if (typeof _sb_stabilizeHard === 'function') _sb_stabilizeHard(); }catch(e){} }, 0);
      setTimeout(function(){ try{ if (typeof _sb_stabilizeHard === 'function') _sb_stabilizeHard(); }catch(e){} }, 200);
    }catch(e){}
    try{
      if (window.game && window.STATE){
        game.state = nextState;
        game.zLayer = (nextState===STATE.HYPER?2:(nextState===STATE.SPACE?1:0));
      }
    }catch(e){}
  };
})();

  // --- injected: Quick Resume + Transition Stabilizers ---
  // Resume into the exact saved context (ground / space / hyperspace)
  function applyQuickSave(u){
    try {
      const qs = u && u.quickSave;
      if (!qs) return false;
      // Normalize state string
      const st = (qs.state && (qs.state.name||qs.state)) || null;
      const stateStr = (typeof st === 'string') ? st.toLowerCase() : null;
      game.galaxy=null; game.spaceTarget=null; game.followSelectionId=null; game.selected=null; game.target=null; game.freeTarget=null; if (game.galaxy){ game.galaxy.target=null; game.galaxy.freeTarget=null; }


      // Always (re)build the system first
      const sysSeed = qs.systemSeed || (u.seed+':home'); game.system = (sysSeed==='sol' ? generateSolSystem() : generateSystem(sysSeed)); game.originSeed = (u.originSeed || (u.seed+':home')); try{ if (game.originSeed==='sol'){ setCustomName('sol','Sol'); setCustomName('sol:star','Sol'); } }catch(e){}
      game.currentStarId = qs.currentStarId || 'S-origin';

      function findBodyBySeed(system, seed){
        if (!system || !seed) return null;
        for (const p of (system.planets||[])){
          if (p.seed===seed) return p;
          for (const m of (p.moons||[])){ if (m.seed===seed) return m; }
        }
        return null;
      }

      if (stateStr === 'ground'){
        const body = findBodyBySeed(game.system, qs.worldSeed) || game.system.planets?.[0];
        if (body) placePlayerOnSurface(body);
        game.state = STATE.GROUND; game.zLayer = 0;
        if (qs.player){ game.player.x = qs.player.x||0; game.player.y = qs.player.y||0; }
        if (qs.camera){ game.camera.x = qs.camera.x||game.player.x; game.camera.y = qs.camera.y||game.player.y; }
        setLocLabel(game.system, body||null);
        setJoystickVisible(true);
        try{ document.getElementById('enterBtn').style.display='none'; }catch(e){}
        try{ document.getElementById('warpBtn').style.display='none'; }catch(e){}
        hideStart();
        try{ toast('Resumed on surface.'); }catch(e){}
        return true;
      }
      if (stateStr === 'space'){
        // Space/system view
        game.state = STATE.SPACE; game.zLayer = 1;
        if (qs.camera){ game.camera.x = qs.camera.x||0; game.camera.y = qs.camera.y||0; } else { game.camera.x=0; game.camera.y=0; }
        setLocLabel(game.system, null);
        setJoystickVisible(true);
        try{ document.getElementById('enterBtn').style.display='none'; }catch(e){}
        hideStart();
        try{ toast('Resumed in system.'); }catch(e){}
        return true;
      }
      if (stateStr === 'hyper'){
        // Hyperspace view
        game.galaxy = generateGalaxy(u.seed, game.originSeed, computeStarNameForSystem(game.originSeed));
        if (!game.galaxy.ship) game.galaxy.ship = {x:0,y:0};
        try{ game.galaxy.visited = (Array.isArray(qs.galaxyVisited) ? qs.galaxyVisited.slice() : (game.galaxy.visited||[])); }catch(e){}
        if (qs.galaxyShip){ game.galaxy.ship.x = qs.galaxyShip.x||0; game.galaxy.ship.y = qs.galaxyShip.y||0; }
        const starEntry = (typeof findStarById==='function') ? (findStarById(game.galaxy, game.currentStarId) || (game.galaxy.stars && game.galaxy.stars[0]) || null) : null;
        if (starEntry){ game.selected = { type:'star', ref: starEntry }; if (!qs.galaxyShip){ game.galaxy.ship.x = starEntry.x; game.galaxy.ship.y = starEntry.y - 20; } }
        safeTransition(STATE.HYPER);
        try{ if (game.galaxy){ game.galaxy.target = null; game.galaxy.freeTarget = null; } game.spaceTarget = null; if (game.galaxy && game.galaxy.ship){ game.galaxy.ship.vx = 0; game.galaxy.ship.vy = 0; } }catch(e){}
        setLocLabel(null, null);
        setJoystickVisible(true);
        try{ document.getElementById('enterBtn').style.display='none'; }catch(e){}
        try{ document.getElementById('warpBtn').style.display='none'; }catch(e){}
        hideStart();
        try{ toast('Resumed in hyperspace.'); }catch(e){}
        return true;
      }
    } catch(e){ /* ignore resume failure */ }
    return false;
  }

  // Stronger repair that runs right after transitions
  function stabilizeAfterTransition(){
    try{
      // Hyperspace: ensure galaxy and visuals
      if (game?.state === STATE.HYPER){
        if (!game.galaxy || !Array.isArray(game.galaxy.bgStars)) {
          game.galaxy = generateGalaxy(game?.universe?.seed || 'default', (game.originSeed || ((game?.universe?.seed) ? (game.universe.seed+':home') : null)), computeStarNameForSystem(game.originSeed || ((game?.universe?.seed) ? (game.universe.seed+':home') : '')));
        }
        if (!game.galaxy.ship){ game.galaxy.ship = {x:0,y:0}; }
        try{ if ((!game.galaxy.visited || !game.galaxy.visited.length) && game?.universe?.quickSave?.galaxyVisited) game.galaxy.visited = game.universe.quickSave.galaxyVisited.slice(); }catch(e){}
        const starEntry = (typeof findStarById==='function') ? (findStarById(game.galaxy, game.currentStarId) || (game.galaxy.stars && game.galaxy.stars[0]) || null) : null;
        if (starEntry && (Number.isNaN(game.galaxy.ship.x) || Number.isNaN(game.galaxy.ship.y))) {
          game.galaxy.ship.x = starEntry.x; game.galaxy.ship.y = starEntry.y - 20;
        }
        if (!game.selected && starEntry){ game.selected = { type:'star', ref: starEntry }; }
      }
      // Space: ensure a valid system + sane camera
      if (game?.state === STATE.SPACE){
        if (!game.system || !game.system.star || !(game.system.planets && game.system.planets.length)){
          const seed = (game.system && game.system.seed) || (game?.universe?.seed + ':home');
          game.system = (seed==='sol' ? generateSolSystem() : generateSystem(seed));
          setLocLabel(game.system, null);
        }
        if (!isFinite(game.camera?.x) || !isFinite(game.camera?.y)){ game.camera.x = 0; game.camera.y = 0; }
      }
    } catch(e){}
  }

  try {
    const w = document.getElementById('warpBtn');
    if (w) w.addEventListener('click', ()=>{ setTimeout(stabilizeAfterTransition, 0); setTimeout(stabilizeAfterTransition, 200); });
    const ebtn = document.getElementById('enterBtn');
    if (ebtn) ebtn.addEventListener('click', ()=>{ setTimeout(stabilizeAfterTransition, 0); setTimeout(stabilizeAfterTransition, 200); });
  } catch(e){}
  // --- end injected ---

  const invGrid = document.getElementById('invGrid');
  const moreInv = document.getElementById('moreInv');
  const closeInv = document.getElementById('closeInv');
  moreInv.addEventListener('click', ()=>{ invOverlay.style.display='grid'; });
  closeInv.addEventListener('click', ()=>{ invOverlay.style.display='none'; });
  for(let i=0;i<25;i++){ const s=document.createElement('div'); s.className='slot'; s.textContent='Empty'; s.setAttribute('role','button'); s.tabIndex=0; invGrid.appendChild(s); }

  function refreshSavesUI(){ const saves = loadSaves(); savesList.innerHTML=''; if(saves.length===0){ const p=document.createElement('div'); p.className='muted'; p.textContent='No universes yet. Create one above!'; savesList.appendChild(p); return; } saves.sort((a,b)=>b.lastPlayedAt-a.lastPlayedAt); saves.forEach(sv=>{ const row=document.createElement('div'); row.className='saveItem'; const info=document.createElement('div'); info.innerHTML=`<div class="saveTitle">${escapeHTML(sv.name)}</div><div class="saveMeta">Seed: ${escapeHTML(sv.seed)} • Created ${new Date(sv.createdAt).toLocaleString()}</div>`; const btns=document.createElement('div'); btns.className='saveBtns'; const play=document.createElement('button'); play.className='btnL'; play.textContent='Play'; play.addEventListener('click',()=>startUniverse(sv)); const del=document.createElement('button'); del.className='btnL danger'; del.textContent='Delete'; del.addEventListener('click',()=>{ deleteSave(sv.id); refreshSavesUI(); const densEl=document.getElementById('densitySlider'); const densLbl=document.getElementById('densityVal'); if(densEl&&densLbl){ densLbl.textContent=densEl.value+'%'; densEl.addEventListener('input', ()=>{ densLbl.textContent=densEl.value+'%'; }); } }); btns.appendChild(play); btns.appendChild(del); row.appendChild(info); row.appendChild(btns); savesList.appendChild(row); }); }
  btnRand.addEventListener('click',()=>{ inputSeed.value = randomSeed(); inputSeed.focus(); inputSeed.select && inputSeed.select(); });
  btnCreate.addEventListener('click',()=>{
    const name=(inputName.value||'Universe '+(loadSaves().length+1)).trim();
    const seed=(inputSeed.value||randomSeed()).trim();
    const u={ id:(Date.now().toString(36)+Math.random().toString(36).slice(2)), name, seed, createdAt:Date.now(), lastPlayedAt:Date.now(), version: VERSION };
    try{ const soe=document.getElementById('startOnEarthToggle'); u.startOnEarth = !!(soe && soe.checked); }catch(e){}
    addSave(u); startUniverse(u);
  });
  /* ---- Start a universe ---- */
  function startUniverse(u){
    // Reset the visited‑loaded guard so that travel lines load correctly for each session.
    try { window.__loadedVisitedFromSave = false; } catch(e) {}

    const densEl = document.getElementById('densitySlider');
    const dens = densEl ? Math.max(1, Math.min(100, parseInt(densEl.value||'100',10))) : 100;
    game.galaxyDensity = dens/100;
game.universe = u; u.lastPlayedAt=Date.now(); saveSaves(loadSaves().map(s=>s.id===u.id?u:s));
    try { if (u.quickSave && typeof applyQuickSave==='function'){ if (applyQuickSave(u)) { return; } } } catch(e){}

    if (u && u.startOnEarth) { game.system = generateSolSystem(); game.originSeed = 'sol'; try{ setCustomName('sol','Sol'); setCustomName('sol:star','Sol'); }catch(e){} try{ u.originSeed = 'sol'; saveSaves(loadSaves().map(s=>s.id===u.id?u:s)); }catch(e){} } else { game.system = generateSystem(u.seed+':home'); game.originSeed = (u.seed+':home'); }
    game.currentStarId = 'S-origin';
    game.galaxy = null; game.spaceTarget=null; game.followSelectionId=null; game.selected=null; game.target=null; game.freeTarget=null; if (game.galaxy){ game.galaxy.target=null; game.galaxy.freeTarget=null; }

    const startPlanet = (u && u.startOnEarth) ? (game.system.planets.find(p=>p.name==='Earth')||game.system.planets[0]) : game.system.planets[0];
    placePlayerOnSurface(startPlanet);
    game.state = STATE.GROUND; game.zLayer = 0;
    game.camera.x = game.player.x; game.camera.y = game.player.y;
    setJoystickVisible(true);
    document.getElementById('warpBtn').style.display = 'none';
    document.getElementById('enterBtn').style.display = 'none';
    setLocLabel(game.system, startPlanet);
    hideStart();
    setTimeout(()=>toast(`Welcome to ${u.name}!`, 1400), 200);
  }

  /* HUD buttons */
  document.getElementById('warpBtn').addEventListener('click', ()=>{
    if (game.state===STATE.SPACE){
      if(!game.galaxy) game.galaxy=generateGalaxy(game.universe.seed, (game.originSeed || ((game.universe && game.universe.seed) ? (game.universe.seed+':home') : null)), computeStarNameForSystem(game.originSeed || ((game.universe && game.universe.seed) ? (game.universe.seed+':home') : '')));
      const starEntry = findStarById(game.galaxy, game.currentStarId) || game.galaxy.stars[0];
      game.galaxy.ship.x = starEntry.x; game.galaxy.ship.y = starEntry.y - 20;
      game.selected = { type:'star', ref: starEntry };
      // Load any saved travel path into this galaxy on warp (so saves from ground/space still keep lines)
      try {
        var savedVisited = (game && game.universe && game.universe.quickSave && Array.isArray(game.universe.quickSave.galaxyVisited)) ? game.universe.quickSave.galaxyVisited : null;
        if (savedVisited && savedVisited.length && (!window.__loadedVisitedFromSave && (!game.galaxy.visited || !game.galaxy.visited.length))) { game.galaxy.visited = savedVisited.slice(); window.__loadedVisitedFromSave = true; }
      } catch(e){}
      safeTransition(STATE.HYPER);
      try { if (!game.galaxy.visited) game.galaxy.visited = []; const last = game.galaxy.visited[game.galaxy.visited.length-1]; if (last !== starEntry.id) game.galaxy.visited.push(starEntry.id); } catch(e){}
        try{ if (game.galaxy){ game.galaxy.target = null; game.galaxy.freeTarget = null; } game.spaceTarget = null; if (game.galaxy && game.galaxy.ship){ game.galaxy.ship.vx = 0; game.galaxy.ship.vy = 0; } }catch(e){}
      document.getElementById('warpBtn').style.display = 'none';
      setLocLabel(null,null);
      setJoystickVisible(true); toast('Warp Drive ONLINE.');
    }
    else if (game.state===STATE.HYPER){ safeTransition(STATE.SPACE); setLocLabel(game.system,null); toast('Exiting hyperspace.'); }
  });

  document.getElementById('enterBtn').addEventListener('click', ()=>{
  if (!game.galaxy || !game.selected || game.selected.type!=='star') return;
  const s = game.selected.ref;
  try { if (game.state===STATE.HYPER) { if (!game.galaxy.visited) game.galaxy.visited = []; } } catch(e){} // Compute screen delta of selected star relative to ship
  const sx = VIEW_W/2 + (s.x - game.galaxy.ship.x);
  const sy = VIEW_H/2 + (s.y - game.galaxy.ship.y);
  const dx = sx - VIEW_W/2, dy = sy - VIEW_H/2;
  const d = Math.hypot(dx, dy);
  // Require being centered before entering; if not, set a target and bail
  if (d > 6) {
    game.galaxy.target = s;
    game.galaxy.freeTarget = null;
    document.getElementById('enterBtn').style.display='none';
    return;
  }
  // Enter currently selected star's system
  game.system = (s.seed==='sol' ? generateSolSystem() : generateSystem(s.seed));
  // record which star system we've entered so exits return here
  try{ game.currentStarId = s.id; }catch(e){}
  game.hideShipDuringLand = false; if (game.anim) game.anim = null;
  try{ _sb_resetCanvasHard && _sb_resetCanvasHard(); }catch(e){}
  game.system.star.name = computeStarNameForSystem(s.seed);
  game.system.name = game.system.star.name;
  game.selected = null; game.followSelectionId = null; game.spaceTarget = null;
  game.state = STATE.SPACE; game.zLayer = 1;
  setLocLabel(game.system, null);
  document.getElementById('enterBtn').style.display='none';
  document.getElementById('warpBtn').style.display='none';
  setJoystickVisible(true);
});

  /* ---- Game loop ---- */
  function update(dt){
    game.tick++;
    if (game.state===STATE.GROUND){
      if (game.stick.active && (Math.abs(game.stick.dx)+Math.abs(game.stick.dy) > 0.01)) {
        const amp = Math.min(1, Math.hypot(game.stick.dx, game.stick.dy));
        const nx = amp ? game.stick.dx / amp : 0;
        const ny = amp ? game.stick.dy / amp : 0;
        const s = game.player.speed * amp * 3.0; // normalized, slower
        game.player.x += nx * s * dt;
        game.player.y += ny * s * dt;
        game.player.dir = Math.abs(nx)>Math.abs(ny) ? (nx>0?'right':'left') : (ny>0?'down':'up');
        game.player.frameTimer += dt; if (game.player.frameTimer>130){ game.player.frame=(game.player.frame+1)%3; game.player.frameTimer=0; }
      } else {
        game.player.frame=1;
      }
      game.camera.x = lerp(game.camera.x, game.player.x, game.cameraSmooth);
      game.camera.y = lerp(game.camera.y, game.player.y, game.cameraSmooth);
      document.getElementById('warpBtn').style.display = 'none';
      setJoystickVisible(true);
    }
    else if (game.state===STATE.SPACE){
      if (game.stick.active && (Math.abs(game.stick.dx)+Math.abs(game.stick.dy) > 0.01)) {
        const amp = Math.min(1, Math.hypot(game.stick.dx, game.stick.dy));
        const nx = amp ? game.stick.dx / amp : 0;
        const ny = amp ? game.stick.dy / amp : 0;
        const base = 0.675; // joystick half speed
        const speed = base * amp * (dt/16);
        game.camera.x += nx * speed * 10;
        game.camera.y += ny * speed * 10;
        game.spaceTarget = null; game._noFollowUntil = Date.now() + 1800;
      } else if (game.spaceTarget) {  let dx=0, dy=0, d=0;  if (game.spaceTarget.type==='body' && game.selected) {    const pos = getBodyScreenPos(game.selected);    if (pos) { dx = pos.x - VIEW_W/2; dy = pos.y - VIEW_H/2; d = Math.hypot(dx,dy); }  } else if (typeof game.spaceTarget.x === 'number' && typeof game.spaceTarget.y === 'number') {    dx = game.spaceTarget.x; dy = game.spaceTarget.y; d = Math.hypot(dx,dy);  }  if (d > 0.6) { const speed = 0.625*(dt/16); const step = speed*6; const move = Math.min(step, d); if (d>0) { game.camera.x += (dx/d)*move; game.camera.y += (dy/d)*move; } }  else { game.camera.x += dx; game.camera.y += dy; const __sel=game.selected; if (__sel&&__sel.ref&&__sel.ref.seed){ game.followSelectionId=__sel.type+':'+__sel.ref.seed; } game.spaceTarget = null; try { refreshActionUI(); } catch(e){} }}game.system.planets.forEach(p=>{ p.theta += 0.00012*(30/p.orbit)*(dt/16); p.moons.forEach(m=> m.theta += 0.0004*(dt/16)); });
      // Orbit-follow: keep the locked body centered after orbits tick
      if (game._noFollowUntil && Date.now() < game._noFollowUntil) { game.followSelectionId = null; }
      if (!(game.stick && game.stick.active && (Math.abs(game.stick.dx)+Math.abs(game.stick.dy) > 0.01)) && game.followSelectionId && game.selected) {
        const cur = game.selected.type + ':' + (game.selected.ref ? game.selected.ref.seed : '');
        if (cur === game.followSelectionId) {
          const pos = getBodyScreenPos(game.selected);
          if (pos) { game.camera.x += (pos.x - VIEW_W/2); game.camera.y += (pos.y - VIEW_H/2); }
        } else { game.followSelectionId = null; }
      }

      document.getElementById('warpBtn').style.display = 'inline-grid';
      setJoystickVisible(true);
    }
    else if (game.state===STATE.HYPER){
      if (game.stick.active && (Math.abs(game.stick.dx)+Math.abs(game.stick.dy) > 0.01)) {
        const speed = 0.275 * (dt/16) * (0.4 + Math.min(1, Math.hypot(game.stick.dx, game.stick.dy)));
        game.galaxy.ship.x += game.stick.dx * speed * 9;
        game.galaxy.ship.y += game.stick.dy * speed * 9;
        game.galaxy.target = null; game.galaxy.freeTarget = null;
        document.getElementById('enterBtn').style.display='none';
      } else if (game.galaxy.target) {
        const t=game.galaxy.target; const dx=t.x-game.galaxy.ship.x, dy=t.y-game.galaxy.ship.y; const d=Math.hypot(dx,dy);
        if(d>0.5){ game.galaxy.ship.x += dx/d * game.galaxy.ship.speed * (dt/16); game.galaxy.ship.y += dy/d * game.galaxy.ship.speed * (dt/16); document.getElementById('enterBtn').style.display='none'; }
        else { game.galaxy.ship.x = t.x; game.galaxy.ship.y = t.y;  document.getElementById('enterBtn').style.display='inline-grid'; }
      } else if (game.galaxy.freeTarget) {
        const t=game.galaxy.freeTarget; const dx=t.x-game.galaxy.ship.x, dy=t.y-game.galaxy.ship.y; const d=Math.hypot(dx,dy);
        if(d>0.5){ game.galaxy.ship.x += dx/d * game.galaxy.ship.speed * (dt/16); game.galaxy.ship.y += dy/d * game.galaxy.ship.speed * (dt/16); }
        else { game.galaxy.ship.x = t.x; game.galaxy.ship.y = t.y;  game.galaxy.freeTarget=null; }
      
      // Auto select nearest star when close
      try {
        const PAD=200, lx=game.galaxy.ship.x - VIEW_W/2 - PAD, rx=game.galaxy.ship.x + VIEW_W/2 + PAD, ty=game.galaxy.ship.y - VIEW_H/2 - PAD, by=game.galaxy.ship.y + VIEW_H/2 + PAD;
        const localStars = getStarsInView(game.galaxy);
        const staticStars = (game.galaxy.stars||[]).filter(ss=> ss.x>=lx&&ss.x<=rx&&ss.y>=ty&&ss.y<=by);
        const stars = localStars.concat(staticStars);
        let nearest=null, best=1e9;
        for (const s0 of stars){ const sx=VIEW_W/2 + (s0.x - game.galaxy.ship.x), sy=VIEW_H/2 + (s0.y - game.galaxy.ship.y); const d=Math.hypot(sx-VIEW_W/2, sy-VIEW_H/2); if (d<best){ best=d; nearest=s0; } }
        if (nearest && best < 14){ game.selected = { type:'star', ref: nearest }; } else if (game.selected && game.selected.type==='star') { game.selected = null; }
      } catch(e){}
    }
      document.getElementById('warpBtn').style.display = 'none';
      setJoystickVisible(true);
    }

    updateCoordsUI();
    setHealthUI(game.health);
    refreshActionUI();
  }

  function render(){
    if (game.state===STATE.GROUND){
      clear('#000'); drawSurface(game.world, game.camera.x, game.camera.y);
      drawPlayer(VIEW_W/2, VIEW_H/2, game.player.dir, game.player.frame);
      const sx=VIEW_W/2+(game.ship.x-game.camera.x), sy=VIEW_H/2+(game.ship.y-game.camera.y); drawShip(sx, sy);
    }
    else if (game.state===STATE.SPACE){ try{ if(typeof validateSystemStrict==='function' && !validateSystemStrict()){ _sb_stabilizeHard && _sb_stabilizeHard(); } drawSpace(game.system, game.camera.x, game.camera.y); }catch(e){ try{ _sb_resetCanvasHard && _sb_resetCanvasHard(); }catch(__){} try{ _sb_stabilizeHard && _sb_stabilizeHard(); }catch(_e){} } }
    else if (game.state===STATE.HYPER){ drawGalaxy(game.galaxy); }
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.max(8, Math.min(50, now-last)); last=now;
    if (document.getElementById('startOverlay').style.display!=='none'){ /* menu only */ }
    else { update(dt); render(); renderAnimOverlay(dt); }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  
  function showStart(){ try{ window.menuStarsActive=true; const ms=document.getElementById('menuStars'); if(ms){ ms.style.display='block'; } if(typeof drawMenuStars==='function'){ drawMenuStars._last = performance.now(); requestAnimationFrame(()=>drawMenuStars(16)); } }catch(e){}  document.body.classList.add('menuOpen'); startOverlay.style.display='grid'; refreshSavesUI(); const densEl=document.getElementById('densitySlider'); const densLbl=document.getElementById('densityVal'); if(densEl&&densLbl){ densLbl.textContent=densEl.value+'%'; densEl.addEventListener('input', ()=>{ densLbl.textContent=densEl.value+'%'; 
  }); } fitCanvas(); }
  function hideStart(){ document.body.classList.remove('menuOpen'); startOverlay.style.display='none'; 
  try{ window.menuStarsActive = false; document.getElementById('menuStars').style.display='none'; }catch(e){}
}
showStart();

  window.addEventListener('contextmenu', (e)=> e.preventDefault());
})();
</script>

<!--
  Global Change Log handler
  The existing Change Log overlay logic inside this file may fail to initialize
  due to scoping or syntax errors, which causes the Settings Change Log button
  either to fall back to a non‑functional panel or to do nothing.  To ensure
  players can always open and close the Change Log, we define a global
  `populateAndOpen` function here.  It reconstructs the change log overlay
  contents from the CHANGELOG object and wires up the close handlers every
  time it is invoked.  This implementation is robust against earlier script
  failures because it runs in its own scope and attaches itself to the
  window.
-->
<script>
  (function(){
    /**
     * Populate the change log overlay with notes and show it.
     */
    function openChangelog(){
      try{
        var v = (window.VERSION || "0.0.90");
        var ov = document.getElementById('changelogOverlay');
        var ver = document.getElementById('changelogVer');
        var body = document.getElementById('changelogList');
        if(!ov || !body) return;
        if(ver) ver.textContent = 'v' + v;
        // Use the global CHANGELOG object when available
        var logObj = window.CHANGELOG || {};
        // Sort keys descending semver‑ish
        var keys = Object.keys(logObj).sort(function(a,b){
          var pa=a.split('.').map(Number), pb=b.split('.').map(Number);
          for(var i=0;i<3;i++){ if ((pb[i]||0)!==(pa[i]||0)) return (pb[i]||0)-(pa[i]||0); }
          return 0;
        });
        var html = '';
        var shown = 0, maxShow = 5;
        for(var i=0; i<keys.length && shown<maxShow; i++){
          var key = keys[i];
          var list = logObj[key] || [];
          html += '<div class="muted"><strong>v'+key+'</strong></div>';
          html += '<ul>';
          if(list.length === 0) html += '<li>No notes.</li>';
          for(var j=0; j<list.length; j++) html += '<li>'+list[j]+'</li>';
          html += '</ul>';
          shown++;
        }
        body.innerHTML = html;
        ov.style.display = 'flex';
        // Setup close behaviour
        function close(){ ov.style.display = 'none'; document.removeEventListener('keydown', onKey); }
        // Attach close handler to the dedicated close button.  Some older
        // versions of the markup did not assign an id to the close button, so
        // fall back to selecting the first button within the overlay if
        // necessary.  This ensures the visible “Close” button actually closes
        // the overlay.
        var btn = document.getElementById('closeChangelog') || (ov ? ov.querySelector('button') : null);
        if (btn) btn.onclick = close;
        ov.onclick = function(e){ if(e.target===ov) close(); };
        function onKey(e){ if(e.key === 'Escape') close(); }
        document.addEventListener('keydown', onKey);
      }catch(e){ /* swallow */ }
    }
    // Expose globally so Settings Change Log button can call it
    window.populateAndOpen = openChangelog;
  })();
</script>

</script>

<!-- Final fallback: robust procedural terrain override that waits for drawSurface to exist and then overrides it. -->
<script>
(function(){
  // 32‑bit FNV‑1a hash → unsigned int
  function fnv1a32(s){ let h=0x811c9dc5>>>0; for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 0x01000193); } return h>>>0; }
  // Simple xorshift32 PRNG returning [0,1)
  function prng32(seed){ let x=seed>>>0; return function(){ x|=0; x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return ((x>>>0)/4294967296); }; }
  const TILE_SIZE = 256;
  const tileCache = {};
  let currentBodyHash = 0;
  let currentTint = null;
  function getTint(){ if (currentTint && currentTint.length>=3) return currentTint; return [96,128,96]; }
  function makeTile(cx, cy){
    const key = cx + ',' + cy + ':' + currentBodyHash;
    if (tileCache[key]) return tileCache[key];
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = TILE_SIZE;
    const ctx2 = cvs.getContext('2d');
    const img = ctx2.createImageData(TILE_SIZE, TILE_SIZE);
    const tint = getTint();
    const seed = (currentBodyHash + ((cx * 374761393)>>>0) + ((cy * 668265263)>>>0))>>>0;
    const rand = prng32(seed);
    let idx = 0;
    for (let y=0; y<TILE_SIZE; y++){
      for (let x=0; x<TILE_SIZE; x++, idx+=4){
        const n = rand();
        const f = 0.7 + n * 0.3;
        img.data[idx]   = Math.min(255, (tint[0] * f) | 0);
        img.data[idx+1] = Math.min(255, (tint[1] * f) | 0);
        img.data[idx+2] = Math.min(255, (tint[2] * f) | 0);
        img.data[idx+3] = 255;
      }
    }
    ctx2.putImageData(img, 0, 0);
    tileCache[key] = cvs;
    return cvs;
  }
  function applyOverride(){
    if (typeof window.drawSurface !== 'function'){
      setTimeout(applyOverride, 50);
      return;
    }
    const orig = window.drawSurface;
    window.drawSurface = function(world, camx, camy){
      if (world && Array.isArray(world.tintRGB) && world.tintRGB.length>=3){
        currentTint = [world.tintRGB[0]|0, world.tintRGB[1]|0, world.tintRGB[2]|0];
      }
      if (typeof hideInfoButtons === 'function') hideInfoButtons();
      if (typeof clear === 'function') clear('#05060a');
      const halfW = VIEW_W/2, halfH = VIEW_H/2;
      const startX = Math.floor((camx - halfW) / TILE_SIZE);
      const startY = Math.floor((camy - halfH) / TILE_SIZE);
      const endX   = Math.floor((camx + halfW) / TILE_SIZE);
      const endY   = Math.floor((camy + halfH) / TILE_SIZE);
      for (let cy = startY; cy <= endY; cy++){
        for (let cx = startX; cx <= endX; cx++){
          const tile = makeTile(cx, cy);
          const dx = Math.round(cx * TILE_SIZE - (camx - halfW));
          const dy = Math.round(cy * TILE_SIZE - (camy - halfH));
          ctx.drawImage(tile, dx, dy);
        }
      }
    };
    if (typeof window.placePlayerOnSurface === 'function'){
      const oldPlace = window.placePlayerOnSurface;
      window.placePlayerOnSurface = function(planet){
        oldPlace(planet);
        try{
          const seedStr = String(planet && planet.seed ? planet.seed : '');
          currentBodyHash = fnv1a32(seedStr);
          if (planet && Array.isArray(planet.groundTint) && planet.groundTint.length>=3){
            currentTint = [planet.groundTint[0]|0, planet.groundTint[1]|0, planet.groundTint[2]|0];
          } else if (game && game.world && Array.isArray(game.world.tintRGB) && game.world.tintRGB.length>=3){
            currentTint = [game.world.tintRGB[0]|0, game.world.tintRGB[1]|0, game.world.tintRGB[2]|0];
          } else {
            currentTint = null;
          }
        }catch(err){
          console.warn('[terrain patch] failed to compute hash/tint', err);
          currentBodyHash = 0; currentTint = null;
        }
      };
    }
  }
  applyOverride();
})();
</script>
<!-- Added by v0.0.44: grass texture system -->
<!-- removed stray script prefix -->
<!-- Added by v0.0.44‑b: grass texture system (fixed loader) -->
<script>
/* === Grass texture loader === */
const GRASS_SRC_SIZE = 128;
const GRASS_VARIANTS = 10;
const GRASS_PATH_PREFIX = 'assets/textures/';
const GRASS_SHEET_NAME = 'grassHR_sprite_sheet.png';
const GRASS_CACHE_IMG = {};
let grassReady = false;

// Pre‑load: try sheet first, else fall back to individual tiles
const GRASS_SHEET = new Image();
GRASS_SHEET.onload = () => { grassReady = true; console.log('[Grass] sprite sheet loaded'); };
GRASS_SHEET.onerror = () => {
  console.warn('[Grass] sprite sheet missing, loading individual tiles');
  let loaded = 0;
  for (let i=0;i<GRASS_VARIANTS;i++){
    const img = new Image();
    img.onload = () => {
      GRASS_CACHE_IMG['src_'+i] = img;
      if (++loaded === GRASS_VARIANTS) { grassReady = true; }
    };
    img.src = GRASS_PATH_PREFIX + 'grassHR' + i + '.png';
  }
};
GRASS_SHEET.src = GRASS_PATH_PREFIX + GRASS_SHEET_NAME;

/* HSL→RGB helper */
function hslToRgb(h,s,l){ h%=360; s=Math.max(0,Math.min(1,s)); l=Math.max(0,Math.min(1,l));
const c=(1-Math.abs(2*l-1))*s; const hp=h/60; const x=c*(1-Math.abs(hp%2-1)); let [r1,g1,b1]=[0,0,0];
if (0<=hp&&hp<1){[r1,g1]=[c,x];} else if (1<=hp&&hp<2){[r1,g1]=[x,c];} else if (2<=hp&&hp<3){[g1,b1]=[c,x];}
else if (3<=hp&&hp<4){[g1,b1]=[x,c];} else if (4<=hp&&hp<5){[r1,b1]=[x,c];} else if (5<=hp&&hp<6){[r1,b1]=[c,x];}
const m=l-c/2; return [Math.round((r1+m)*255),Math.round((g1+m)*255),Math.round((b1+m)*255)]; }

/* Retrieve tinted variant (with caching) */
function getTintedGrassTile(variant, tint){
  const key = variant + '-' + tint.join(',');
  if (GRASS_CACHE_IMG[key]) return GRASS_CACHE_IMG[key];

  // Source image
  let baseImg;
  if (GRASS_SHEET.complete && GRASS_SHEET.naturalWidth){
    const cvs = document.createElement('canvas');
    cvs.width=cvs.height=GRASS_SRC_SIZE;
    const cx=cvs.getContext('2d',{alpha:true});
    cx.imageSmoothingEnabled=false;
    const sx=(variant%5)*GRASS_SRC_SIZE;
    const sy=Math.floor(variant/5)*GRASS_SRC_SIZE;
    cx.drawImage(GRASS_SHEET,sx,sy,GRASS_SRC_SIZE,GRASS_SRC_SIZE,0,0,GRASS_SRC_SIZE,GRASS_SRC_SIZE);
    baseImg = cvs;
  }else if (GRASS_CACHE_IMG['src_'+variant]){
    baseImg = GRASS_CACHE_IMG['src_'+variant];
  }else{
    return null;
  }

  const tintCanvas = document.createElement('canvas');
  tintCanvas.width = tintCanvas.height = GRASS_SRC_SIZE;
  const ctxT = tintCanvas.getContext('2d',{alpha:true});
  ctxT.imageSmoothingEnabled=false;
  ctxT.drawImage(baseImg,0,0);
  ctxT.globalCompositeOperation='source-atop';
  ctxT.fillStyle=`rgb(${tint[0]},${tint[1]},${tint[2]})`;
  ctxT.fillRect(0,0,GRASS_SRC_SIZE,GRASS_SRC_SIZE);
  GRASS_CACHE_IMG[key]=tintCanvas;
  return tintCanvas;
}

/* Patch drawSurface */
if (typeof drawSurface === 'function'){
  /* Override ground rendering with a simple deterministic noise generator.
     This avoids dependence on the missing grass sprite sheet and ensures
     planets always have a visible terrain. Each chunk tile is seeded from
     the planet seed and tile coordinates. */
  const ORIGINAL_tileDraw = drawSurface;
  // 32‑bit FNV‑1a hash → unsigned int
  function fnv1a32(s){ let h = 0x811c9dc5>>>0; for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 0x01000193); } return h>>>0; }
  // Simple xorshift32 PRNG returning [0,1)
  function prng32(seed){ let x=seed>>>0; return function(){ x|=0; x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return ((x>>>0)/4294967296); }; }
  const TILE_SIZE = 256;
  const tileCache = {};
  // Current body hash and tint colours – updated on landing via hook below
  let currentBodyHash = 0;
  let currentTint = null;
  function getTint(){ if (currentTint && currentTint.length>=3) return currentTint; return [96,128,96]; }
  function makeTile(cx, cy){
    const key = cx + ',' + cy + ':' + currentBodyHash;
    if (tileCache[key]) return tileCache[key];
    const cvs = document.createElement('canvas');
    cvs.width = cvs.height = TILE_SIZE;
    const c2 = cvs.getContext('2d');
    const img = c2.createImageData(TILE_SIZE, TILE_SIZE);
    const tint = getTint();
    // Derive a unique seed per tile from body hash and coordinates
    const seed = (currentBodyHash + ((cx * 374761393)>>>0) + ((cy * 668265263)>>>0))>>>0;
    const rand = prng32(seed);
    let idx = 0;
    for (let y=0; y<TILE_SIZE; y++){
      for (let x=0; x<TILE_SIZE; x++, idx+=4){
        const n = rand();
        // Bias noise brightness: base 0.7 → 1.0
        const f = 0.7 + n * 0.3;
        img.data[idx]   = Math.min(255, (tint[0] * f) | 0);
        img.data[idx+1] = Math.min(255, (tint[1] * f) | 0);
        img.data[idx+2] = Math.min(255, (tint[2] * f) | 0);
        img.data[idx+3] = 255;
      }
    }
    c2.putImageData(img, 0, 0);
    tileCache[key] = cvs;
    return cvs;
  }
  drawSurface = function(world, camx, camy){
    // Clear the ground layer and hide info buttons just like original
    if (typeof hideInfoButtons === 'function') hideInfoButtons();
    if (typeof clear === 'function') clear('#05060a');
    // If the world has a tint assigned, update currentTint for this body
    if (world && Array.isArray(world.tintRGB) && world.tintRGB.length>=3){
      currentTint = [world.tintRGB[0]|0, world.tintRGB[1]|0, world.tintRGB[2]|0];
    }
    const halfW = VIEW_W / 2, halfH = VIEW_H / 2;
    const startX = Math.floor((camx - halfW) / TILE_SIZE);
    const startY = Math.floor((camy - halfH) / TILE_SIZE);
    const endX = Math.floor((camx + halfW) / TILE_SIZE);
    const endY = Math.floor((camy + halfH) / TILE_SIZE);
    for (let cy = startY; cy <= endY; cy++){
      for (let cx = startX; cx <= endX; cx++){
        const tile = makeTile(cx, cy);
        const dx = Math.round(cx * TILE_SIZE - (camx - halfW));
        const dy = Math.round(cy * TILE_SIZE - (camy - halfH));
        ctx.drawImage(tile, dx, dy);
      }
    }
  };
}

/* Hook placePlayerOnSurface to update the currentBodyHash and tint when landing.
   Without this, every planet would share the same noise pattern. */
if (typeof placePlayerOnSurface === 'function'){
  const _oldPlace = placePlayerOnSurface;
  placePlayerOnSurface = function(planet){
    _oldPlace(planet);
    try{
      const seedStr = String(planet && planet.seed ? planet.seed : '');
      currentBodyHash = fnv1a32(seedStr);
      if (planet && Array.isArray(planet.groundTint) && planet.groundTint.length>=3){
        currentTint = [planet.groundTint[0]|0, planet.groundTint[1]|0, planet.groundTint[2]|0];
      } else if (game && game.world && Array.isArray(game.world.tintRGB) && game.world.tintRGB.length>=3){
        currentTint = [game.world.tintRGB[0]|0, game.world.tintRGB[1]|0, game.world.tintRGB[2]|0];
      } else {
        currentTint = null;
      }
    }catch(e){
      console.warn('[terrain noise] error computing seed/tint', e);
      currentBodyHash = 0; currentTint = null;
    }
  };
}

/* Assign random tint per planet/moon */
if (typeof placePlayerOnSurface==='function'){
  const oldPlace = placePlayerOnSurface;
  placePlayerOnSurface = function(planet){
    oldPlace(planet);
    const r = seededRandom ? seededRandom('grassTint:'+planet.seed) : Math.random;
    const hue = Math.floor(r()*360);
    planet.groundTint = hslToRgb(hue, 0.65, 0.45);
    if (game && game.world) game.world.tintRGB = planet.groundTint;
  };
}
</script>

</script>
<!-- Procedural terrain fallback injection removed -->
<script type="x-removed">
(function(){
  // Simple 32-bit FNV-1a hash for seeding pseudo-random noise
  function hashSeed(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); } return h>>>0; }
  // xorshift32 PRNG generator producing values in [0,1)
  function makePrng(seed){ let x=seed>>>0; return function(){ x|=0; x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return ((x>>>0)/4294967296); }; }
  const TILE_SIZE=256;
  const cache={};
  function getBaseTint(){ if(window.currentTint && window.currentTint.length>=3) return window.currentTint; return [96,128,96]; }
  function generateTile(cx,cy){ const key=cx+','+cy+':' + (window.currentBodyHash||0); if(cache[key]) return cache[key]; const cvs=document.createElement('canvas'); cvs.width=cvs.height=TILE_SIZE; const ctx2=cvs.getContext('2d'); const img=ctx2.createImageData(TILE_SIZE,TILE_SIZE); const tint=getBaseTint(); const seed=((window.currentBodyHash||0)+cx*374761393+cy*668265263)>>>0; const prng=makePrng(seed); let i=0; for(let y=0;y<TILE_SIZE;y++){ for(let x=0;x<TILE_SIZE;x++,i+=4){ const n=prng(); const f=0.7+n*0.3; img.data[i]  = Math.min(255,(tint[0]*f)|0); img.data[i+1]= Math.min(255,(tint[1]*f)|0); img.data[i+2]= Math.min(255,(tint[2]*f)|0); img.data[i+3]=255; } } ctx2.putImageData(img,0,0); cache[key]=cvs; return cvs; }
  // Override drawSurface to draw procedural noise tiles when in ground state
  const oldDrawSurface=window.drawSurface;
  window.drawSurface=function(world, camx, camy){ if(typeof hideInfoButtons==='function') hideInfoButtons(); if(typeof clear==='function') clear('#05060a'); const size=TILE_SIZE; const halfW=VIEW_W/2; const halfH=VIEW_H/2; const startX=Math.floor((camx-halfW)/size); const startY=Math.floor((camy-halfH)/size); const endX=Math.floor((camx+halfW)/size); const endY=Math.floor((camy+halfH)/size); for(let cy=startY; cy<=endY; cy++){ for(let cx=startX; cx<=endX; cx++){ const tile=generateTile(cx,cy); const dx=Math.round(cx*size - (camx-halfW)); const dy=Math.round(cy*size - (camy-halfH)); ctx.drawImage(tile, dx, dy); } } };
  // Hook placePlayerOnSurface to derive per-planet seed and tint
  if(typeof placePlayerOnSurface==='function'){ const prev=placePlayerOnSurface; window.placePlayerOnSurface=function(planet){ prev(planet); try{ const seedStr=String(planet&&planet.seed?planet.seed:''); window.currentBodyHash=hashSeed(seedStr); let tint=null; if(planet && Array.isArray(planet.groundTint)) tint=planet.groundTint; else if(game && game.world && Array.isArray(game.world.tintRGB)) tint=game.world.tintRGB; if(tint && tint.length>=3) window.currentTint=[tint[0]|0, tint[1]|0, tint[2]|0]; else window.currentTint=null; }catch(e){ console.warn('[terrain fallback] error computing seed/tint', e); window.currentBodyHash=0; window.currentTint=null; } }; }
})();
</script>

<script>
// 0.0.57: Robust Settings open/close (closest-based, works on menu + in-game)
(function(){
  function openSettings(){ const o=document.getElementById('settingsOverlay'); if(o){ o.style.display='flex'; o.scrollTop=0; } }
  function closeSettings(){ var o=document.getElementById("settingsOverlay"); if(o){ o.style.display="none"; } try{ if (typeof fitCanvas==="function") setTimeout(fitCanvas, 0); }catch(e){} } }
  document.addEventListener('click', function(e){
    const btn = e.target.closest && e.target.closest('#settingsBtn, #menuSettingsBtn');
    if (btn) { e.preventDefault(); openSettings(); return; }
    if (e.target && e.target.id==='closeSettings') closeSettings();
  });
  document.addEventListener('keydown', function(e){ if(e.key==='Escape') closeSettings(); });
  document.addEventListener('DOMContentLoaded', ()=>{
    const o = document.getElementById('settingsOverlay');
    if (o){ o.addEventListener('click', (e)=>{ if (e.target===o) closeSettings(); }); }
  });
})();
</script>

<script>
/* 0.0.57 MusicService v3: classic-only loop, no overlap */
(function(){
  const SETTINGS_KEY = 'spacebitz:settings2';
  function load(){ try{return JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}');}catch(e){return{};} }
  function save(s){ try{localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));}catch(e){} }
  window.SETTINGS = Object.assign({music:true}, window.SETTINGS||load());

  let ctx=null, master=null, busMel=null;
  let running=false, scheduler=null, nextTime=0, tempo=96, beat=0;
  const lookahead=0.05, ahead=0.30;
  function AC(){ return window.AudioContext||window.webkitAudioContext; }
  function ensure(){
    if (ctx) return;
    const C = AC(); if (!C) return;
    ctx = new C();
    master = ctx.createGain(); master.gain.value = 0; master.connect(ctx.destination);
    busMel = ctx.createGain(); busMel.gain.value = 1; busMel.connect(master);
    nextTime = ctx.currentTime + 0.1;
  }
  function noteFreq(n){ return 440 * Math.pow(2,(n-69)/12); }
  function env(g, t, v, a=0.01, r=0.10){ g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(v, t+a); g.gain.setTargetAtTime(0, t+0.24, r); }
  function playClassicPhrase(t){
    // Matches the classic vibe used earlier: triangle lead + saw bass
    const root=64, scale=[0,2,4,7,9], pat=[0,2,4,2,0,2,4,7];
    for(let i=0;i<pat.length;i++){
      const o=ctx.createOscillator(), g=ctx.createGain();
      o.type='triangle'; o.frequency.value=noteFreq(root+scale[pat[i]%scale.length]);
      o.connect(g); g.connect(busMel);
      env(g, t+i*0.25, 0.12, 0.01, 0.08);
      o.start(t+i*0.25); o.stop(t+i*0.25+0.5);
    }
    for(let i=0;i<8;i++){
      const o=ctx.createOscillator(), g=ctx.createGain();
      o.type='sawtooth'; o.frequency.value=noteFreq(40+(i%4===0?0:-5));
      o.connect(g); g.connect(busMel);
      env(g, t+i*0.5, 0.06, 0.01, 0.12);
      o.start(t+i*0.5); o.stop(t+i*0.5+0.6);
    }
  }
  window.MUSIC = { ensure, get ctx(){return ctx;}, start, stop };
  function schedule(){
    if (!ctx) return;
    const spb = 60/tempo;
    while (nextTime < ctx.currentTime + ahead){
      // Every 8 beats = 2 bars -> play the phrase once; this naturally loops
      if (beat % 8 === 0){
        playClassicPhrase(nextTime);
      }
      beat++;
      nextTime += spb;
    }
  }
  function tick(){ if (running) schedule(); }
  function start(){
    ensure(); if (!ctx || running) return;
    running = true;
    if (!scheduler) scheduler = setInterval(tick, lookahead*1000);
    const t = ctx.currentTime;
    master.gain.cancelScheduledValues(t);
    master.gain.setValueAtTime(master.gain.value, t);
    master.gain.linearRampToValueAtTime(0.8, t+1.0);
  }
  function stop(){
    if (!ctx) return;
    const t = ctx.currentTime;
    master.gain.cancelScheduledValues(t);
    master.gain.setValueAtTime(master.gain.value, t);
    master.gain.linearRampToValueAtTime(0.0, t+0.8);
    running = false;
    if (scheduler){ clearInterval(scheduler); scheduler=null; }
  }
  function toggle(on){ if (on) start(); else stop(); }
  window.MusicService = { start, stop, toggle, _ensure:ensure };

  document.addEventListener('DOMContentLoaded', ()=>{
    const chk = document.getElementById('musicToggle');
    if (chk){
      chk.checked = !!(window.SETTINGS && window.SETTINGS.music);
      chk.addEventListener('change', ()=>{ window.SETTINGS.music=!!chk.checked; save(window.SETTINGS); toggle(window.SETTINGS.music); });
      window.addEventListener('pointerdown', ()=>ensure(), {once:true});
      if (window.SETTINGS.music) setTimeout(start, 400);
    }
  });
})();
</script>

<script>
// 0.0.57: ensure Platform & HUD sections are present in the Settings panel
(function(){
  function addPlatformBlock(){
    const panel = document.getElementById('settingsPanel'); if (!panel) return;
    if (panel.querySelector('#platformBlock')) return; // already added
    const unitsRow = panel.querySelector('select#units')?.closest('.row') || panel.children[0];
    const block = document.createElement('div'); block.id='platformBlock';
    block.innerHTML = `
      <hr>
      <div class="title" style="font-size:14px;opacity:.85;margin:6px 0 8px">Platform</div>
      <div class="row">
        <label>Mode</label>
        <div class="segCtl">
          <input type="radio" name="mode" id="modeMobile"><label for="modeMobile">Mobile</label>
          <input type="radio" name="mode" id="modeDesktop"><label for="modeDesktop">Desktop</label>
        </div>
        <div class="right subtle">Desktop hides joystick</div>
      </div>
      <div class="row" id="resRow">
        <label>Resolution</label>
        <select id="resPreset" class="btnL">
          <option value="auto">Auto (fit window)</option>
          <option value="960x540">960 × 540</option>
          <option value="1280x720">1280 × 720</option>
          <option value="1600x900">1600 × 900</option>
          <option value="1920x1080">1920 × 1080</option>
        </select>
        <div class="right subtle">Desktop only</div>
      </div>
      <hr>
      <div class="title" style="font-size:14px;opacity:.85;margin:6px 0 8px">HUD Layout (Desktop)</div>
      <div class="row">
        <label>Edit HUD</label>
        <input id="hudEdit" type="checkbox">
        <div class="right subtle">Drag to move; resize handles to size/scale</div>
      </div>
    `;
    panel.appendChild(block);

    // Wire controls
    const SETTINGS_KEY = 'spacebitz:settings2';
    function load(){ try{return JSON.parse(localStorage.getItem(SETTINGS_KEY)||'{}');}catch(e){return{};} }
    function save(s){ try{localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));}catch(e){} }
    window.SETTINGS = Object.assign({mode:'mobile',resPreset:'auto'}, window.SETTINGS||load());
    const mobile = block.querySelector('#modeMobile'), desktop = block.querySelector('#modeDesktop');
    const resSel = block.querySelector('#resPreset'); const hudEdit = block.querySelector('#hudEdit');
    if (mobile){ mobile.checked = (window.SETTINGS.mode!=='desktop'); }
    if (desktop){ desktop.checked = (window.SETTINGS.mode==='desktop'); }
    if (resSel){ resSel.value = window.SETTINGS.resPreset || 'auto'; }
    if (hudEdit){ hudEdit.checked = !!window.SETTINGS.hudEnabled; }
    function applyUIMode(){
      document.body.classList.toggle('desktopMode', window.SETTINGS.mode==='desktop');
      document.body.classList.toggle('customHud', window.SETTINGS.mode==='desktop' && !!window.SETTINGS.hudEnabled);
      // Hide/show joystick immediately
      var joy = document.getElementById('joystick');
      if (joy) joy.style.display = (window.SETTINGS.mode==='desktop') ? 'none' : '';
      if (typeof fitCanvas==='function') fitCanvas();
      if (typeof applyHudLayout==='function') applyHudLayout();
    }
      if (typeof applyHudLayout==='function'){ applyHudLayout(); }
    }
    mobile?.addEventListener('change', ()=>{ window.SETTINGS.mode='mobile'; save(window.SETTINGS); applyUIMode(); });
    desktop?.addEventListener('change', ()=>{ window.SETTINGS.mode='desktop'; save(window.SETTINGS); applyUIMode(); });
    resSel?.addEventListener('change', ()=>{ window.SETTINGS.resPreset=resSel.value; save(window.SETTINGS); if (typeof fitCanvas==='function') fitCanvas(); });
    hudEdit?.addEventListener('change', ()=>{ window.SETTINGS.hudEnabled=!!hudEdit.checked; save(window.SETTINGS); applyUIMode(); });

    applyUIMode();
  }
  if (document.readyState==='complete' || document.readyState==='interactive') addPlatformBlock();
  else document.addEventListener('DOMContentLoaded', addPlatformBlock);
})();
</script>

<script>
// 0.0.57: Delegated mode/res/hud listeners so it works in-game too
(function(){
  const KEY='spacebitz:settings2';
  function load(){ try{return JSON.parse(localStorage.getItem(KEY)||'{}');}catch(e){return{};} }
  function save(s){ try{localStorage.setItem(KEY, JSON.stringify(s));}catch(e){} }
  window.SETTINGS = Object.assign({mode:'mobile',resPreset:'auto'}, window.SETTINGS||load());

  function applyUIMode(){
      document.body.classList.toggle('desktopMode', window.SETTINGS.mode==='desktop');
      document.body.classList.toggle('customHud', window.SETTINGS.mode==='desktop' && !!window.SETTINGS.hudEnabled);
      // Hide/show joystick immediately
      var joy = document.getElementById('joystick');
      if (joy) joy.style.display = (window.SETTINGS.mode==='desktop') ? 'none' : '';
      if (typeof fitCanvas==='function') fitCanvas();
      if (typeof applyHudLayout==='function') applyHudLayout();
    }

  document.addEventListener('change', (e)=>{
    if (e.target && (e.target.id==='modeMobile' || e.target.id==='modeDesktop')){
      window.SETTINGS.mode = (e.target.id==='modeDesktop') ? 'desktop' : 'mobile';
      save(window.SETTINGS); applyUIMode();
    }
    if (e.target && e.target.id==='resPreset'){
      window.SETTINGS.resPreset = e.target.value; save(window.SETTINGS);
      if (typeof fitCanvas==='function') fitCanvas();
    }
    if (e.target && e.target.id==='hudEdit'){
      window.SETTINGS.hudEnabled = !!e.target.checked; save(window.SETTINGS); applyUIMode();
    }
  }, true);

  // Update radio states when opening settings
  function syncRadios(){
    const dm=document.getElementById('modeDesktop'), mm=document.getElementById('modeMobile'), rs=document.getElementById('resPreset'), he=document.getElementById('hudEdit');
    if (dm) dm.checked = window.SETTINGS.mode==='desktop';
    if (mm) mm.checked = window.SETTINGS.mode!=='desktop';
    if (rs) rs.value = window.SETTINGS.resPreset || 'auto';
    if (he) he.checked = !!window.SETTINGS.hudEnabled;
  }
  document.addEventListener('click', (e)=>{
    const btn = e.target.closest && e.target.closest('#settingsBtn, #menuSettingsBtn');
    if (btn) setTimeout(syncRadios, 0);
  });
  document.addEventListener('DOMContentLoaded', syncRadios);
})();
</script>

<script>
// 0.0.57: explicit open function + binding for main-menu Settings
(function(){
  window.openSettingsOverlay = function(){
    var o = document.getElementById('settingsOverlay');
    if (o){ o.style.display='flex'; o.scrollTop = 0; }
  };
   }
  document.addEventListener('DOMContentLoaded', function(){
    var mBtn = document.getElementById('menuSettingsBtn');
    if (mBtn){ mBtn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); window.openSettingsOverlay(); }); }
    var sBtn = document.getElementById('settingsBtn');
    if (sBtn){ sBtn.addEventListener('click', function(e){ e.preventDefault(); window.openSettingsOverlay(); }); }
    var overlay = document.getElementById('settingsOverlay');
    if (overlay){ overlay.addEventListener('click', function(e){ if (e.target===overlay) closeSettings(); }); }
    document.addEventListener('keydown', function(e){ if (e.key==='Escape') closeSettings(); });
  });
})();
</script>

<script>
// 0.0.57: delegated desktop/mobile handlers + immediate joystick hide
(function(){
  var KEY='spacebitz:settings2';
  function load(){ try{return JSON.parse(localStorage.getItem(KEY)||'{}');}catch(e){return{};} }
  function save(s){ try{localStorage.setItem(KEY, JSON.stringify(s));}catch(e){} }
  window.SETTINGS = Object.assign({mode:'mobile',resPreset:'auto'}, window.SETTINGS||load());

  window.applyUIMode = function(){
    document.body.classList.toggle('desktopMode', window.SETTINGS.mode==='desktop');
    document.body.classList.toggle('customHud', window.SETTINGS.mode==='desktop' && !!window.SETTINGS.hudEnabled);
    var joy = document.getElementById('joystick');
    if (joy) joy.style.display = (window.SETTINGS.mode==='desktop') ? 'none' : '';
    if (typeof fitCanvas==='function') fitCanvas();
    if (typeof applyHudLayout==='function') applyHudLayout();
  };

  document.addEventListener('change', function(e){
    if (!e.target) return;
    if (e.target.id==='modeDesktop' || e.target.id==='modeMobile'){
      window.SETTINGS.mode = (e.target.id==='modeDesktop') ? 'desktop' : 'mobile';
      save(window.SETTINGS); window.applyUIMode();
    } else if (e.target.id==='resPreset'){
      window.SETTINGS.resPreset = e.target.value; save(window.SETTINGS);
      if (typeof fitCanvas==='function') fitCanvas();
    } else if (e.target.id==='hudEdit'){
      window.SETTINGS.hudEnabled = !!e.target.checked; save(window.SETTINGS);
      window.applyUIMode();
    }
  }, true);

  function sync(){
    var dm=document.getElementById('modeDesktop'), mm=document.getElementById('modeMobile'), rs=document.getElementById('resPreset'), he=document.getElementById('hudEdit');
    if (dm) dm.checked = window.SETTINGS.mode==='desktop';
    if (mm) mm.checked = window.SETTINGS.mode!=='desktop';
    if (rs) rs.value = window.SETTINGS.resPreset || 'auto';
    if (he) he.checked = !!window.SETTINGS.hudEnabled;
  }
  document.addEventListener('DOMContentLoaded', function(){ sync(); window.applyUIMode(); });
  document.addEventListener('click', function(e){
    var btn = e.target && e.target.closest && e.target.closest('#settingsBtn, #menuSettingsBtn');
    if (btn) setTimeout(sync, 0);
  });
})();
</script>

<script>
// .51: ensure main menu Settings opens the overlay
document.addEventListener('DOMContentLoaded', function(){
  var btn = document.getElementById('menuSettingsBtn');
  var overlay = document.getElementById('settingsOverlay');
  if (btn && overlay){
    btn.addEventListener('click', function(e){
      e.preventDefault();
      overlay.style.display='flex';
      // sync UI controls
      try {
        var dm=document.getElementById('modeDesktop'), mm=document.getElementById('modeMobile'), rs=document.getElementById('resPreset'), he=document.getElementById('hudEdit');
        if (dm) dm.checked = (window.SETTINGS && window.SETTINGS.mode==='desktop');
        if (mm) mm.checked = !(window.SETTINGS && window.SETTINGS.mode==='desktop');
        if (rs && window.SETTINGS) rs.value = window.SETTINGS.resPreset || 'auto';
        if (he && window.SETTINGS) he.checked = !!window.SETTINGS.hudEnabled;
      } catch(_){}
    });
  }
});
</script>

<script>
// .51: robust desktop/mobile apply on radio change and on open
(function(){
  var KEY='spacebitz:settings2';
  function load(){ try{return JSON.parse(localStorage.getItem(KEY)||'{}');}catch(e){return{};} }
  function save(s){ try{localStorage.setItem(KEY, JSON.stringify(s));}catch(e){} }
  window.SETTINGS = Object.assign({mode:'mobile',resPreset:'auto'}, window.SETTINGS||load());
  function applyUIMode(){
    document.body.classList.toggle('desktopMode', window.SETTINGS.mode==='desktop');
    document.body.classList.toggle('customHud', window.SETTINGS.mode==='desktop' && !!window.SETTINGS.hudEnabled);
    var joy = document.getElementById('joystick');
    if (joy){ joy.style.display = (window.SETTINGS.mode==='desktop') ? 'none' : ''; }
    if (typeof fitCanvas==='function') fitCanvas();
    if (typeof applyHudLayout==='function') applyHudLayout();
  }
  function syncRadios(){
    var dm=document.getElementById('modeDesktop'), mm=document.getElementById('modeMobile');
    if (dm) dm.checked = window.SETTINGS.mode==='desktop';
    if (mm) mm.checked = window.SETTINGS.mode!=='desktop';
  }
  document.addEventListener('change', function(e){
    if (e.target && e.target.id==='modeDesktop'){ window.SETTINGS.mode='desktop'; save(window.SETTINGS); applyUIMode(); }
    if (e.target && e.target.id==='modeMobile'){ window.SETTINGS.mode='mobile'; save(window.SETTINGS); applyUIMode(); }
  }, true);
  document.addEventListener('DOMContentLoaded', function(){ applyUIMode(); syncRadios(); });
  // Also sync when overlay opens via any button
  document.addEventListener('click', function(e){
    var btn = e.target.closest && e.target.closest('#settingsBtn, #menuSettingsBtn');
    if (btn) setTimeout(syncRadios,0);
  });
})();
</script>

<script>
// .51: Ensure Platform and HUD sections exist in settings panel
(function(){
  function ensureBlocks(){
    var panel = document.getElementById('settingsPanel'); if (!panel) return;
    if (!panel.querySelector('#platformBlock')){
      var block = document.createElement('div'); block.id='platformBlock';
      block.innerHTML = `
        <hr>
        <div class="title" style="font-size:14px;opacity:.85;margin:6px 0 8px">Platform</div>
        <div class="row">
          <label>Mode</label>
          <label><input type="radio" name="mode" id="modeMobile"> Mobile</label>
          <label><input type="radio" name="mode" id="modeDesktop"> Desktop</label>
        </div>
        <div class="row" id="resRow">
          <label>Resolution</label>
          <select id="resPreset" class="btnL">
            <option value="auto">Auto (fit window)</option>
            <option value="960x540">960 × 540</option>
            <option value="1280x720">1280 × 720</option>
            <option value="1600x900">1600 × 900</option>
            <option value="1920x1080">1920 × 1080</option>
          </select>
          <div class="right subtle">Desktop only</div>
        </div>
        <hr>
        <div class="title" style="font-size:14px;opacity:.85;margin:6px 0 8px">HUD Layout (Desktop)</div>
        <div class="row">
          <label>Edit HUD</label>
          <input id="hudEdit" type="checkbox">
          <div class="right subtle">Drag to move; resize handles to size/scale</div>
        </div>`;
      panel.appendChild(block);
    }
  }
  if (document.readyState!=='loading') ensureBlocks();
  else document.addEventListener('DOMContentLoaded', ensureBlocks);
})();
</script>

<script>
(function bindMenuSettingsBtn(){
  var btn = document.getElementById('menuSettingsBtn');
  if (btn && typeof window.openSettingsOverlay === 'function'){
    btn.addEventListener('click', function(e){ e.preventDefault(); e.stopPropagation(); window.openSettingsOverlay(); });
  }
})();
</script>

<script>
(function(){
  try{
    var t = document.getElementById('settingsVer');
    if (t && typeof VERSION !== 'undefined') t.textContent = 'v' + VERSION;
  }catch(e){}
})();
</script>

<script>
(function(){ try{ var t=document.getElementById('settingsVer'); if(t && typeof VERSION!=='undefined'){ t.textContent='v'+VERSION; } }catch(e){} })();
</script>

<script>
// ensure Settings shows version text
(function(){ try{ var el=document.getElementById('settingsVer'); if(el && typeof VERSION!=='undefined'){ el.textContent='v'+VERSION; } }catch(e){} })();
</script>

<script>
// Center the joystick stick at all times
(function(){
  var joy = document.getElementById('joystick');
  var stick = document.getElementById('stick');
  function centerStick(){ if(!joy||!stick) return;
  // center via CSS vars (keeps left/top at 50% via stylesheet)
  stick.style.setProperty('--dx','0px');
  stick.style.setProperty('--dy','0px');
}
// normalize left/top in case earlier code touched absolute px
stick.style.left='50%'; stick.style.top='50%';
window.centerStick = centerStick;
  if (document.readyState!=='loading') centerStick();
  else document.addEventListener('DOMContentLoaded', centerStick);
  window.addEventListener('resize', centerStick);
})();
</script>

<script>
// 0.0.58: show version in Settings header
(function(){
  try{ var el = document.getElementById('settingsVer'); if (el) el.textContent = 'v' + (window.VERSION || '0.0.60');
var mv = document.getElementById('menuVer'); if (mv) mv.textContent = 'v' + (window.VERSION || '0.0.60'); }catch(e){}
})();
</script>
<script>function hashCode(str){ let h=0; for(let i=0;i<str.length;i++){ h=((h<<5)-h+str.charCodeAt(i))|0; } return h>>>0; }</script>

<!-- 0.0.72 overrides: richer palette + system texture to better match ground -->
<script>
(function(){
  // Override: richer palette (deeper water, more diverse land) and improved ensureBodyTexture
  function _planetTexturePalette(baseHex, arche){
    function parseColor(c){
      const m = /#([0-9a-f]{6})/i.exec(c||''); 
      if (m){ const v=parseInt(m[1],16); return [(v>>16)&255,(v>>8)&255,v&255]; }
      return [96,128,96];
    }
    const base = parseColor(baseHex);
    const clamp = x=>Math.max(0,Math.min(255,x));
    const tintMix = (rgb,amt)=>[clamp(rgb[0]*(1-amt)+base[0]*amt), clamp(rgb[1]*(1-amt)+base[1]*amt), clamp(rgb[2]*(1-amt)+base[2]*amt)];
    const WATER = { base:[26,88,170], accent:[40,120,200] };
    const GRASS = { base:[68,128,74], accent:[96,156,98] };
    const ROCK  = { base:[110,110,110], accent:[140,140,140] };
    const SAND  = { base:[205,178,120], accent:[232,206,146] };
    const DIRT  = { base:[126,96,62],  accent:[152,118,79]  };
    const ICE   = { base:[175,205,230], accent:[210,235,255] };
    const SWAMP = { base:[60,92,60],    accent:[82,116,82]  };
    return {
      water: WATER.base, waterAccent: WATER.accent,
      grass: tintMix(GRASS.base,0.18), grass2: tintMix(GRASS.accent,0.12),
      rock:  tintMix(ROCK.base,0.10),
      sand:  tintMix(SAND.base,0.12),
      dirt:  tintMix(DIRT.base,0.10),
      ice:   ICE.base, snow: ICE.accent,
      swamp: tintMix(SWAMP.base,0.12)
    };
  }
  window._planetTexturePalette = _planetTexturePalette;

  // Safer FBM util using existing _makePerlin2
  function _fbm2(per, x, y, f){
    let n=0, amp=0.55, norm=0, fr=f;
    for(let k=0;k<4;k++){ n += amp * per(x*fr, y*fr); norm+=amp; amp*=0.55; fr*=2.05; }
    return (n/(norm||1))*0.5+0.5;
  }
  function _domainWarp(per, x, y, f, amp){
    const wx = per(x*f, y*f) * amp;
    const wy = per((x+1000)*f, (y-777)*f) * amp;
    return [x+wx, y+wy];
  }

  const _oldEnsure = window._ensureBodyTexture;
  window._ensureBodyTexture = function(body, baseColor){
    try{
      const cacheKey = body.seed + '::' + (body.R||0);
      if (body._texKey === cacheKey && body._tex) return;
      const R = Math.max(3, body.R|0);
      const S = R*2;
      const off = document.createElement('canvas'); off.width = off.height = S;
      const g = off.getContext('2d', { willReadFrequently:true });
      const per = (window._makePerlin2 ? window._makePerlin2(body.seed||'x') : (x,y)=>0);
      const pal = _planetTexturePalette(baseColor, 'auto');
      const cx = R, cy = R;
      const img = g.createImageData(S, S);
      const data = img.data;

      const ELEV_F = 0.0035 * (256/R);
      const MOIST_F= 0.0020 * (256/R);
      const TEMP_F = 0.0016 * (256/R);
      const sea = 0.48;

      for (let j=0;j<S;j++){
        for (let i=0;i<S;i++){
          const dx = (i - cx + 0.5), dy = (j - cy + 0.5);
          const rr = dx*dx + dy*dy;
          const idx = (j*S + i) * 4;
          if (rr > R*R){ data[idx+3]=0; continue; }
          const nx = dx / R, ny = dy / R;
          const nz2 = 1 - nx*nx - ny*ny;
          const nz = nz2>0 ? Math.sqrt(nz2) : 0;
          const WX = nx * (R*2.8), WY = ny * (R*2.8);
          const d = _domainWarp(per, WX, WY, 0.0008, 120.0*(R/128));
          const elev  = _fbm2(per, d[0], d[1], ELEV_F);
          const moist = _fbm2(per, d[0]+333.3, d[1]-222.2, MOIST_F);
          const temp  = _fbm2(per, d[0]-123.4, d[1]+555.5, TEMP_F);
          const patch = _fbm2(per, d[0]+777.7, d[1]-999.9, 0.05);
          // lightweight slope
          const e1 = _fbm2(per,d[0]+2,d[1],ELEV_F), e2=_fbm2(per,d[0]-2,d[1],ELEV_F), e3=_fbm2(per,d[0],d[1]+2,ELEV_F), e4=_fbm2(per,d[0],d[1]-2,ELEV_F);
          const slope = Math.min(1, Math.hypot(e1-e2, e3-e4)*6);

          let rgb;
          if (elev < sea){
            const depth = (sea - elev) / sea;
            const w = [ pal.water[0]*(0.8+0.2*nz), pal.water[1]*(0.8+0.2*nz), pal.water[2]*(0.8+0.2*nz) ];
            const wa = pal.waterAccent;
            rgb = [ (w[0]*(1-depth) + wa[0]*depth)|0, (w[1]*(1-depth)+wa[1]*depth)|0, (w[2]*(1-depth)+wa[2]*depth)|0 ];
          } else if (temp < 0.27) {
            rgb = (patch>0.35) ? pal.snow : pal.rock;
          } else if (moist < 0.28) {
            rgb = (patch>0.25) ? pal.sand : (slope>0.6 ? pal.rock : pal.dirt);
          } else if (patch < 0.9) {
            const t = 0.35 + 0.65*patch;
            rgb = [ (pal.grass[0]*(1-t)+pal.grass2[0]*t)|0, (pal.grass[1]*(1-t)+pal.grass2[1]*t)|0, (pal.grass[2]*(1-t)+pal.grass2[2]*t)|0 ];
          } else {
            rgb = (slope>0.65 ? pal.rock : (moist>0.75 ? pal.swamp : pal.dirt));
          }
          // lighting: keep water rich
          let shade = 0.55 + nz*0.45;
          if (elev < sea) shade = 0.85 + nz*0.15;
          data[idx]  = Math.min(255, rgb[0]*shade)|0;
          data[idx+1]= Math.min(255, rgb[1]*shade)|0;
          data[idx+2]= Math.min(255, rgb[2]*shade)|0;
          data[idx+3]= 255;
        }
      }
      g.putImageData(img, 0, 0);
      body._tex = off; body._texKey = cacheKey;
    }catch(e){
      // Fallback to old ensure if something goes wrong
      if (typeof _oldEnsure === 'function') _oldEnsure(body, baseColor);
    }
  };
})();
</script>

<script>
// === v0.0.75 Time & Label System ===
(function(){
  const STORAGE_KEY = 'spacebitz:timeMode';
  // default to GAME if unset
  const _storedTM = localStorage.getItem(STORAGE_KEY);
  window.TIME_MODE = (_storedTM==='real' || _storedTM==='local') ? _storedTM : ((_storedTM==='game') ? 'local' : 'local');
  try{ if (_storedTM==='game') localStorage.setItem(STORAGE_KEY, 'local'); }catch(e){}

  // Clock runtime state
  window.__clk = window.__clk || {
    startRealMs: null,     // when session started (real ms)
    baseGameMin: 0,        // minutes carried over from saves
    baseDateMs: null,      // UTC 00:00 date start (ms)
    lastUtcMinute: null,   // cache minute for UTC updates
    lastLocalMinute: null, // cache minute for Local updates
    lastGameSec: -1,       // cache sec for GAME updates (1 sec = +1 minute)
    fps: null,             // last FPS seen
    lastCoords: {x:0,y:0,z:0}
  };

  function pad(n){ return (n<10?'0':'')+n; }
  function fmtUTC(ms){
    const d = new Date(ms);
    return d.getUTCFullYear()+'-'+pad(d.getUTCMonth()+1)+'-'+pad(d.getUTCDate())+' '+pad(d.getUTCHours())+':'+pad(d.getUTCMinutes())+' UTC';
  }

  // Store the latest "path" label (names only)
  window.__locPathLabel = window.__locPathLabel || null;

  // Build the name key (dots + time + meta) from a plain "Star • Planet • (Moon)" path
  window.buildLocHTML = function(pathLabel){
    window.__locPathLabel = pathLabel || window.__locPathLabel || '—';
    const el = document.getElementById('locLabel'); if (!el) return;
    const parts = String(window.__locPathLabel).split(/\s*•\s*/);
    let path = '';
    if (parts[0]) path += '<span class="dot star"></span>'+parts[0];
    if (parts[1]) path += ' &nbsp;•&nbsp; <span class="dot planet"></span>'+parts[1];
    if (parts[2]) path += ' &nbsp;•&nbsp; <span class="dot moon"></span>'+parts[2];
    // time line placeholder (filled by tickTime immediately)
    const line = '<span id="locTimeLine" class="loc-time">—</span>';
    const meta = '<span id="locMetaLine" class="loc-meta">X: 0  Y: 0  Z: 0  |  FPS: --</span>';
    el.innerHTML = '<div class="loc-path">'+path+'</div>'+line+meta; try{ refreshLocMeta(); }catch(e){}
  };

  // Compute current GAME time ms from base date + elapsed seconds (1 sec -> +1 minute)
  function getGameTimeMs(){
    if (__clk.baseDateMs==null){
      const d = new Date(); d.setUTCHours(0,0,0,0); __clk.baseDateMs = d.getTime();
    }
    if (__clk.startRealMs==null) __clk.startRealMs = Date.now();
    const elapsedSec = Math.max(0, Math.floor((Date.now() - __clk.startRealMs)/1000));
    const totalMin = (__clk.baseGameMin|0) + elapsedSec;        // 1 sec -> +1 min
    return __clk.baseDateMs + totalMin*60*1000;
  }

  // Refresh the time, efficiently
  function refreshTime(){

    const line = document.getElementById('locTimeLine'); if (!line) return;
    if (window.TIME_MODE==='real'){
      const now = new Date();
      const minute = now.getUTCFullYear()+'-'+pad(now.getUTCMonth()+1)+'-'+pad(now.getUTCDate())+' '+pad(now.getUTCHours())+':'+pad(now.getUTCMinutes());
      if (minute !== __clk.lastUtcMinute){
        __clk.lastUtcMinute = minute;
        line.textContent = 'UTC ' + minute;
      }
    } else { // local
      const now = new Date();
      const minute = now.getFullYear()+'-'+pad(now.getMonth()+1)+'-'+pad(now.getDate())+' '+pad(now.getHours())+':'+pad(now.getMinutes());
      if (minute !== __clk.lastLocalMinute){
        __clk.lastLocalMinute = minute;
        line.textContent = 'Local ' + minute;
      }
    }
  }

  // Compose "coords + fps" into the meta line
  function refreshLocMeta(){
    try{
      var ml = document.getElementById('locMetaLine');
      if (!ml) return;
      var c = (window.__clk && window.__clk.lastCoords) ? window.__clk.lastCoords : {x:0,y:0,z:0};
      var f = (window.__clk && window.__clk.fps!=null) ? window.__clk.fps : '--';
      var scEl = document.getElementById('showCoords');
      var sfEl = document.getElementById('showFPS');
      var showC = (scEl ? !!scEl.checked : (window.SETTINGS ? !!window.SETTINGS.showCoords : true));
      var showF = (sfEl ? !!sfEl.checked : (window.SETTINGS ? !!window.SETTINGS.showFPS : true));
      var parts = [];
      if (showC) parts.push('X: ' + c.x + '  Y: ' + c.y + '  Z: ' + c.z);
      if (showF) parts.push('FPS: ' + f);
      ml.textContent = parts.join('  |  ');
      ml.style.display = parts.length ? '' : 'none';
    }catch(e){} 
  }

  // Interval ticker: updates time and meta regardless of engine loop order
  function _captureCoordsFps(){
    try{
      const elC = document.getElementById('coords');
      if (elC){ const m=/X:\s*(-?\d+)\s+Y:\s*(-?\d+)\s+Z:\s*(-?\d+)/.exec(elC.textContent||''); if(m){ __clk.lastCoords={x:m[1],y:m[2],z:m[3]}; }}
      const elF = document.getElementById('fps');
      if (elF){ const m=/FPS:\s*(\d+)/.exec(elF.textContent||''); if(m){ __clk.fps=m[1]; }}
    }catch(e){}
  }
  document.addEventListener('DOMContentLoaded', function(){
    try{ setInterval(function(){ refreshTime(); _captureCoordsFps(); refreshLocMeta(); }, 250); }catch(e){}
  });

  // Wrap updateCoordsUI to capture coords and refresh meta
  if (typeof window.updateCoordsUI === 'function'){
    const _uc = window.updateCoordsUI;
    window.updateCoordsUI = function(){
      const r = _uc.apply(this, arguments);
      try{
        const el = document.getElementById('coords');
        if (el){
          const m = /X:\s*(-?\d+)\s+Y:\s*(-?\d+)\s+Z:\s*(-?\d+)/.exec(el.textContent||'');
          if (m){ __clk.lastCoords = {x: m[1], y: m[2], z: m[3]}; }
        }
        refreshLocMeta();
      }catch(e){}
      return r;
    };
  }

  // Wrap updateFPS to capture fps and refresh meta
  if (typeof window.updateFPS === 'function'){
    const _uf = window.updateFPS;
    window.updateFPS = function(dt){
      const r = _uf.apply(this, arguments);
      try{
        const el = document.getElementById('fps');
        if (el){
          const m = /FPS:\s*(\d+)/.exec(el.textContent||'');
          if (m) __clk.fps = m[1];
          refreshLocMeta();
        }
      }catch(e){}
      return r;
    };
  }

  // Moon-aware label builder: setLocLabel(system, world)
  (function(){
    // Patch setLocLabel so we keep a clean path string (prevents stacking)
    const orig = window.setLocLabel;
    window.setLocLabel = function(system, world){
      try{
        let label;
        if (!world){
          label = system.name;
        } else {
          // If world is a moon, include host planet between system and moon
          if (world._kind === 'Moon'){
            const host = (system.planets||[]).find(p=>(p.moons||[]).some(m=>m.seed===world.seed));
            label = system.name + ' • ' + (host?host.name:'?') + ' • ' + world.name;
          } else {
            // World could still be a moon object passed as world; detect host
            const maybeHost = (system.planets||[]).find(p=>(p.moons||[]).some(m=>m.seed===world.seed));
            if (maybeHost && maybeHost.seed !== world.seed){
              label = system.name + ' • ' + maybeHost.name + ' • ' + world.name;
            } else {
              label = system.name + ' • ' + world.name;
            }
          }
        }
        buildLocHTML(label);
      }catch(e){}
      if (typeof orig === 'function') return orig.apply(this, arguments);
    };
  })();

  // startUniverse: initialize session clock base
  (function(){
    const orig = window.startUniverse;
    window.startUniverse = function(u){
      if (u){
        if (u.gameElapsedMin==null) u.gameElapsedMin = 0;
        if (u.gameDateBaseMs==null){ const d=new Date(); d.setUTCHours(0,0,0,0); u.gameDateBaseMs=d.getTime(); }
        __clk.baseGameMin = u.gameElapsedMin|0;
        __clk.baseDateMs  = u.gameDateBaseMs;
        __clk.startRealMs = Date.now();
      }
      const r = orig ? orig.apply(this, arguments) : undefined;
      try{ if (window.__locPathLabel){ buildLocHTML(window.__locPathLabel); } }catch(e){}
      return r;
    };
  })();

  // applyQuickSave: restore clock and mode
  if (typeof window.applyQuickSave === 'function'){
    const _apply = window.applyQuickSave;
    window.applyQuickSave = function(u){
      const r = _apply.apply(this, arguments);
      try{
        if (u && u.quickSave){
          if (u.quickSave.gameElapsedMin!=null) u.gameElapsedMin = u.quickSave.gameElapsedMin|0;
          if (u.quickSave.gameDateBaseMs!=null) u.gameDateBaseMs = u.quickSave.gameDateBaseMs|0;
          __clk.baseGameMin = u.gameElapsedMin|0;
          __clk.baseDateMs  = u.gameDateBaseMs;
          __clk.startRealMs = Date.now();
          if (u.quickSave.timeMode){ window.TIME_MODE = (u.quickSave.timeMode==='real'?'real':'local'); }
          try{ localStorage.setItem(STORAGE_KEY, window.TIME_MODE); }catch(e){}
          if (window.__locPathLabel){ buildLocHTML(window.__locPathLabel); }
        }
      }catch(e){}
      return r;
    };
  }

  // Save & Quit: persist time + mode
  document.addEventListener('DOMContentLoaded', function(){
    const btn = document.getElementById('saveQuitBtn');
    if (btn){
      btn.addEventListener('click', function(){
        try{
          if (window.game && game.universe){
            const elapsedSec = Math.max(0, Math.floor((Date.now()-(__clk.startRealMs||Date.now()))/1000));
            const totalMin = (__clk.baseGameMin|0) + elapsedSec;
            game.universe.gameElapsedMin = totalMin;
            game.universe.gameDateBaseMs = __clk.baseDateMs || (function(){ const d=new Date(); d.setUTCHours(0,0,0,0); return d.getTime(); })();
            game.universe.quickSave = game.universe.quickSave || {};
            game.universe.quickSave.gameElapsedMin = totalMin;
            game.universe.quickSave.gameDateBaseMs = game.universe.gameDateBaseMs;
            game.universe.quickSave.timeMode = window.TIME_MODE;
          }
        }catch(e){}
        try{ localStorage.setItem(STORAGE_KEY, window.TIME_MODE); }catch(e){}
      }, true);
    }
  });

  // Settings select: no stacking, rebuild from stored path
  document.addEventListener('DOMContentLoaded', function(){
    const sel = document.getElementById('timeModeSelect');
    if (sel){
      sel.value = (window.TIME_MODE==='real'?'real':'local');
      sel.addEventListener('change', function(){
        window.TIME_MODE = (sel.value==='real'?'real':'local');
        try{ localStorage.setItem(STORAGE_KEY, window.TIME_MODE); }catch(e){}
        if (window.__locPathLabel){ buildLocHTML(window.__locPathLabel); } // rebuild one time line (no stacking)
        // force immediate time refresh
        __clk.lastUtcMinute = null; __clk.lastLocalMinute = null; __clk.lastGameSec = -1; refreshTime(); refreshLocMeta();
      });
    }
  });

  // Call refresh once on load
  document.addEventListener('DOMContentLoaded', function(){
    try{ refreshTime(); refreshLocMeta(); }catch(e){}
  });
})();
</script>

<script>
// v0.0.76: clock seconds + robust repaint + launch glitch fix (non-invasive override)
(function(){
  function _p(n){ return (n<10?'0':'')+n; }
  window.refreshTime = function(){
    const el = document.getElementById('locTimeLine'); if (!el) return;
    const now = new Date();
    if (window.TIME_MODE==='real'){
      const stamp = now.getUTCFullYear()+'-'+_p(now.getUTCMonth()+1)+'-'+_p(now.getUTCDate())+' '+_p(now.getUTCHours())+':'+_p(now.getUTCMinutes())+':'+_p(now.getUTCSeconds());
      const desired = 'UTC ' + stamp;
      if (el.textContent !== desired) el.textContent = desired;
    } else {
      const stamp = now.getFullYear()+'-'+_p(now.getMonth()+1)+'-'+_p(now.getDate())+' '+_p(now.getHours())+':'+_p(now.getMinutes())+':'+_p(now.getSeconds());
      const desired = 'Local ' + stamp;
      if (el.textContent !== desired) el.textContent = desired;
    }
  };
  try{
    const _ll = document.getElementById('locLabel');
    if (_ll && window.MutationObserver){
      const obs = new MutationObserver(()=>{ try{ refreshTime(); }catch(e){} });
      obs.observe(_ll, { childList:true, subtree:true });
    }
  }catch(_){}
})();
</script>

  <!-- Change Log Overlay -->
  <section id="changelogOverlay" role="dialog" aria-modal="true" style="display:none; position:fixed; inset:0; z-index:2100; align-items:center; justify-content:center; background:rgba(3,6,14,.65); backdrop-filter: blur(2px);">
    <div id="changelogPanel" class="panel" style="min-width:300px; max-width:90vw;">
      <div class="title">Change Log <span class="ver" id="changelogVer"></span></div>
      <div id="changelogList" class="muted"></div>
      <div class="row" style="justify-content:flex-end;"><button id="closeChangelog" class="btnL" onclick="document.getElementById('changelogOverlay').style.display='none';">Close</button></div>
    </div>
  </section>

<script>
// v0.0.77b: single-icon chip + working overlay from Settings only
(function(){
  var CHANGELOG = {
  "0.0.90": [
    "Fix: Travel lines now persist in your save and resume exactly where you left off.",
    "Fix: Origin stars again display \"Origin\" in hyperspace labels. Format: <name>, Origin, <distance>.",
    "Fix: Hyperspace travel snaps the ship precisely onto the destination star (0 LY away).",
    "Fix: The Execute button is now visible with Cheats → Show Command Line enabled.",
    "Chore: Showing only 0.0.90 in the Change Log."
  ]
};

  // Override the changelog entries to include only notes for this version (0.0.85).
  // The original object above contained historical entries dating back several versions,
  // which cluttered the overlay and made maintenance difficult.  Rather than editing
  // every line of the original declaration — which is static content shipped with the
  // game — we perform a simple reassignment here.  This ensures that the overlay
  // shows only the latest fixes relevant to the currently shipped version and that
  // older notes have been removed entirely.  If future releases need to append
  // additional entries, they can modify this object accordingly.
  // Update change log for version 0.0.85.

  function populateAndOpen(){
    // Use the globally defined VERSION when available; fallback to the latest
    // version string used in this build (0.0.85) if not set.
    var v = (window.VERSION || "0.0.90");
    var ov = document.getElementById('changelogOverlay');
    var ver = document.getElementById('changelogVer');
    var body = document.getElementById('changelogList');
    if(!ov || !body) return;
    if(ver) ver.textContent = "v" + v;

    // Render rolling history: current + previous entries
    var keys = Object.keys(CHANGELOG).sort(function(a,b){
      // sort semver-ish descending
      var pa=a.split('.').map(Number), pb=b.split('.').map(Number);
      for (var i=0;i<3;i++){ if ((pb[i]||0)!==(pa[i]||0)) return (pb[i]||0)-(pa[i]||0); }
      return 0;
    });
    var html = "";
    var shown = 0, maxShow = 5;
    for (var i=0;i<keys.length && shown<maxShow;i++){
      var key = keys[i];
      var list = CHANGELOG[key] || [];
      html += "<div class=\"muted\"><strong>v"+key+"</strong></div>";
      html += "<ul>";
      if(list.length === 0) html += "<li>No notes.</li>";
      for(var j=0;j<list.length;j++) html += "<li>"+list[j]+"</li>";
      html += "</ul>";
      shown++;
    }
    body.innerHTML = html;

    ov.style.display = "flex";
    function close(){
      try{
        ov.style.display = "none";
      }catch(_){/* ignore */}
      // Remove Escape handler after closing to avoid leaks
      document.removeEventListener('keydown', onKey);
    }
    // Always (re)attach the close handler to the button.  Setting both
    // `onclick` and an explicit addEventListener ensures compatibility
    // with browsers that disable inline event handlers or previous
    // assignments.  If multiple listeners are present they all call
    // the same closure, which is idempotent.
    (function(){
      var btn = document.getElementById('closeChangelog');
      if (btn){
        btn.onclick = close;
        btn.addEventListener('click', close);
      }
    })();
    ov.onclick = function(e){ if(e.target===ov) close(); };
    function onKey(e){ if(e.key === "Escape") close(); }
    document.addEventListener('keydown', onKey);
  }

  // Expose the populateAndOpen function on the global object so that other
  // scripts (e.g. the Settings Change Log chip) can detect and call it. Without
  // this assignment, populateAndOpen remains scoped to this IIFE and the
  // fallback handler simply displays the overlay without populating content or
  // wiring up the close button. Attaching it to window ensures proper
  // integration.
  window.populateAndOpen = populateAndOpen;

  function onReady(){
    // Remove any pre-existing Change Log buttons outside Settings
    var allBtns = Array.from(document.querySelectorAll('#changelogBtn'));
    allBtns.forEach(function(el){
      if(!el.closest('#settingsOverlay')) el.remove();
    });

    // Ensure one button in settings title
    var title = document.querySelector('#settingsOverlay .title');
    if(!title) return;
    var btn = document.getElementById('changelogBtn');
    if(!btn || !btn.closest('#settingsOverlay')){
      btn = document.createElement('button');
      btn.id = 'changelogBtn';
      btn.type = 'button';
      btn.className = 'chipBtn';
      btn.textContent = 'Change Log'; // important: text only; no emoji/icons
      // Prefer after the version span if present
      var verSpan = document.getElementById('settingsVer');
      if(verSpan) verSpan.insertAdjacentElement('afterend', btn);
      else title.appendChild(btn);
    }else{
      // Normalize existing
      btn.className = 'chipBtn';
      btn.textContent = 'Change Log';
    }
    btn.onclick = populateAndOpen;
  }
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', onReady);
  else onReady();
})();
</script>

<script>
(function(){
  document.addEventListener('DOMContentLoaded', function(){
    try{ var v = (typeof VERSION!=='undefined'? VERSION : '0.0.78'); 
      var a=document.getElementById('settingsVer'); if(a) a.textContent='v'+v;
      var b=document.getElementById('menuVer'); if(b) b.textContent='v'+v;
    }catch(e){} 
  });
})();
</script>
<script>
// === Patch: respect "Show Coordinates" and "Show FPS" toggles in the top-left meta line ===
(function(){
  // Replace refreshLocMeta with a settings-aware version
  window.refreshLocMeta = function(){
    try{
      var ml = document.getElementById('locMetaLine');
      if (!ml) return;
      var c = (window.__clk && window.__clk.lastCoords) ? window.__clk.lastCoords : {x:0,y:0,z:0};
      var f = (window.__clk && window.__clk.fps!=null) ? window.__clk.fps : '--';
      var showC = (window.SETTINGS ? !!window.SETTINGS.showCoords : true);
      var showF = (window.SETTINGS ? !!window.SETTINGS.showFPS   : true);
      var parts = [];
      if (showC) parts.push('X: ' + c.x + '  Y: ' + c.y + '  Z: ' + c.z);
      if (showF) parts.push('FPS: ' + f);
      ml.textContent = parts.join('  |  ');
      ml.style.display = parts.length ? '' : 'none';
    }catch(e){ /* no-op */ }
  };
  // Ensure meta refresh reacts immediately to checkbox changes and on load
  document.addEventListener('change', function(e){
    if (e && e.target && (e.target.id === 'showCoords' || e.target.id === 'showFPS')){
      try{ window.refreshLocMeta(); }catch(_){}
    }
  });
  document.addEventListener('DOMContentLoaded', function(){
    try{ window.refreshLocMeta(); }catch(_){}
  });
})();


// Command line: validate and show Execute button only on valid command
document.addEventListener('input', function(e){
  if (!e || !e.target || e.target.id !== 'cmdInput') return;
  var btn = document.getElementById('cmdExecBtn');
  if (!btn) return;
  var txt = (e.target.value||'').trim();
  var valid = /^\s*\/tel\s+(-?\d+)\s*,\s*(-?\d+)\s*$/.test(txt) || /^\s*\/tel\s+(-?\d+)\s+(-?\d+)\s*$/.test(txt);
  btn.style.display = valid ? 'inline-grid' : 'none';
});

// Execute button: perform the command
document.addEventListener('click', function(e){
  var _btn = (e && e.target && e.target.closest) ? e.target.closest('#cmdExecBtn') : null;
  if (!_btn) return;
  var input = document.getElementById('cmdInput');
  if (!input) return;
  var txt = (input.value||'').trim();
  var m = /^\s*\/tel\s+(-?\d+)\s*,\s*(-?\d+)\s*$/.exec(txt) || /^\s*\/tel\s+(-?\d+)\s+(-?\d+)\s*$/.exec(txt);
  if (m){
    var x = parseInt(m[1],10), y = parseInt(m[2],10);
    try{
      if (typeof game!=='undefined' && game.state===STATE.HYPER && game.galaxy && game.galaxy.ship){
        // Scale hyperspace coordinates: user enters sector coords (x,y) but ship coordinates use a 10x scale.
        // Multiply by 10 to convert sectors to internal units. Reset velocity and cancel autopilot.
        game.galaxy.target = null;
        game.galaxy.freeTarget = null;
        if (game.galaxy.ship){ game.galaxy.ship.vx = 0; game.galaxy.ship.vy = 0; }
        game.galaxy.ship.x = x * 10;
        game.galaxy.ship.y = y * 10;
        if (typeof toast==='function') try{ toast('Teleported to '+x+', '+y); }catch(_){}
      }
    }catch(_){}
  }
});

document.addEventListener('DOMContentLoaded', function(){
  try{
    var btn = document.getElementById('cmdExecBtn');
    if (btn && !btn._bound){
      btn._bound = true;
      btn.addEventListener('click', function(e){
        e.preventDefault && e.preventDefault();
        e.stopPropagation && e.stopPropagation();
        var input = document.getElementById('cmdInput');
        if (!input) return;
        var txt = (input.value||'').trim();
        var m = /^\s*\/tel\s+(-?\d+(?:\.\d+)?)\s*,\s*(-?\d+(?:\.\d+)?)\s*$/.exec(txt) || /^\s*\/tel\s+(-?\d+(?:\.\d+)?)\s+(-?\d+(?:\.\d+)?)\s*$/.exec(txt);
        if (m){
          var x = Number(m[1]), y = Number(m[2]);
          try{
            if (typeof game!=='undefined' && game.state===STATE.HYPER && game.galaxy && game.galaxy.ship){
              // Scale hyperspace coordinates to internal units by multiplying by 10. No additional
              // offset is required because we want the displayed coordinates (ship.x/10, ship.y/10)
              // to match the entered sector values directly.
              game.galaxy.target = null;
              game.galaxy.freeTarget = null;
              if (game.galaxy.ship){ game.galaxy.ship.vx = 0; game.galaxy.ship.vy = 0; }
              game.galaxy.ship.x = x * 10;
              game.galaxy.ship.y = y * 10;
              if (typeof toast==='function') try{ toast('Teleported to '+x+', '+y); }catch(_){}
            }
          }catch(_){}
        }
      });
    }
  }catch(_){}
});
</script>

<script>
// v0.0.82: "Objects in System" dropdown + "Go to" button (Space)
(function(){
  function ensureUI(){
    if (document.getElementById('sysObjectsWrap')) return;
    const wrap = document.createElement('div');
    wrap.id = 'sysObjectsWrap';
    wrap.setAttribute('aria-label','Objects in System');
    wrap.style.position = 'fixed';
    wrap.style.zIndex = '30';
    wrap.style.left = '8px';
    wrap.style.top = '60px'; // will be updated below
    wrap.style.pointerEvents = 'auto';
    // Use details for native dropdown behavior
    wrap.innerHTML = [
      '<details id="sysObjectsDD" class="sys-dd">',
        '<summary>Objects in System</summary>',
        '<ul id="sysObjectsList"></ul>',
      '</details>',
      '<button id="sysGoBtn" type="button" class="sys-go" aria-label="Go to selected body">Go to</button>'
    ].join('');
    document.body.appendChild(wrap);
    positionUnderTopLeft(); // initial position
  }

  function positionUnderTopLeft(){
    try{
      const topLeft = document.getElementById('topLeft');
      const wrap = document.getElementById('sysObjectsWrap');
      if (!topLeft || !wrap) return;
      const r = topLeft.getBoundingClientRect();
      // place just below topLeft block
      wrap.style.left = Math.round(r.left) + 'px';
      wrap.style.top  = Math.round(r.bottom + 6) + 'px';
    }catch(e){}
  }

  function getDisplayName(obj, fallback){ try{ if(!obj) return fallback||'—'; if (typeof obj.name==='string' && obj.name.trim()) return obj.name.trim(); return fallback||'—'; }catch(e){ return fallback||'—'; } }

  function listBodiesForSystem(sys){
    const items = [];
    if (!sys || !sys.star) return items;
    items.push({ type:'star', ref: sys.star, label: sys.star.name || 'Star' });
    (sys.planets||[]).forEach(p=>{
      items.push({ type:'planet', ref:p, label: p.name || 'Planet' });
      // moons omitted from system dropdown;
    });
    return items;
  }

  let _lastSeed = null;
  let _pending = null;

  function populate(){
    try{
      ensureUI();
      const wrap = document.getElementById('sysObjectsWrap');
      const list = document.getElementById('sysObjectsList');
      const dd = document.getElementById('sysObjectsDD');
      const btn = document.getElementById('sysGoBtn');
      if (!wrap || !list || !dd || !btn) return;
      // Visibility: show only in space view when the game is active and the main menu is not open.
      const inMenu = document && document.body && document.body.classList.contains('menuOpen');
      wrap.hidden = inMenu || !(window.game && game.state === STATE.SPACE);
      if (wrap.hidden) {
        // Clear any stale content and hide the go‑to button when hidden.
        list.innerHTML = '';
        btn.style.display = 'none';
        return;
      }

      const sys = (game && game.system) ? game.system : null;
      const seed = sys ? (sys.seed || sys.name || 'sys-unknown') : 'none';
      if (seed === _lastSeed && list.childElementCount > 0) return; // no rebuild
      _lastSeed = seed;
      list.innerHTML = '';
      _pending = null; btn.style.display = 'none';

      const entries = listBodiesForSystem(sys);
      entries.forEach((ent)=>{
        if (ent && ent.isMoon) return; const li = document.createElement('li');
        li.textContent = ent.label;
        if (ent.isMoon) li.classList.add('moon');
        li.addEventListener('click', ()=>{ try{ _pending = ent; btn.style.display = 'inline-block'; /* Do not set game.selected here */ }catch(e){} });
        list.appendChild(li);
      });
      positionUnderTopLeft();
    }catch(e){ /* swallow */ }
  }

  function hookGo(){
    const btn = document.getElementById('sysGoBtn');
    if (!btn) return;
    btn.addEventListener('click', function(){
            try{
        if (!_pending || !window.game) return;
        if (game.state !== STATE.SPACE) return;
        // Normalize selection and follow lock
        game.selected = { type: _pending.type, ref: _pending.ref };
        game.followSelectionId = (_pending.type + ':' + (_pending.ref ? _pending.ref.seed : ''));
        game._noFollowUntil = 0;
        // Drive the camera toward the target
        if (_pending.type === 'star') {
          // Treat the star like a body for camera movement.  getBodyScreenPos handles
          // stars by returning screen coordinates relative to the camera, allowing the
          // update loop to smoothly move towards (0,0) without NaN values.
          game.spaceTarget = { type: 'body', sel: game.selected };
        } else {
          // For planets and other bodies, animate toward the selected body as usual.
          game.spaceTarget = { type: 'body', sel: game.selected };
        }
        // Safety: reset/stabilize canvas & system next tick to avoid "black screen" on some paths
        setTimeout(()=>{ try{
          if (typeof window._sb_resetCanvasHard === 'function') window._sb_resetCanvasHard();
          if (typeof window._sb_stabilizeHard === 'function') window._sb_stabilizeHard();
        }catch(e){} }, 0);
        // Close the dropdown for feedback
        const dd = document.getElementById('sysObjectsDD'); if (dd && dd.open) dd.open = false;
      }catch(e){ /* swallow */ }
        });
  }

  function init(){
    ensureUI(); hookGo();
    populate();
    // Light polling avoids touching the main update loop
    const iv = setInterval(populate, 600);
    window.addEventListener('resize', positionUnderTopLeft);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else { init(); }
})();
</script>

<script>
       try{ if (typeof toast==='function') toast('Teleport works only in hyperspace.'); }catch(_){}
          return;
        }
        if (!game.galaxy || !game.galaxy.ship) return;
        game.galaxy.freeTarget = null;
        game.galaxy.ship.x = loc.x;
        game.galaxy.ship.y = loc.y;
        try{ if (typeof toast==='function') toast('Teleported to '+loc.x+', '+loc.y); }catch(_){}
        return;
      }
      // Unknown command
      try{ if (typeof toast==='function') toast('Unknown command. Try /tel 10 20'); }catch(_){}
    }catch(_){}
  }
  function hookInput(){
    var input = document.getElementById('cmdInput');
    if (!input) return;
    input.addEventListener('keydown', function(e){
      if (e.key === 'Enter'){
        var t = (input.value||'').trim();
        if (t){ execCommand(t); }
      }
    });
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', hookInput);
  } else { hookInput(); }
})();
</script>

<script>
// v0.0.92 patch: single-source version stamping + settings wiring guard + /tel unit alignment
(function(){
  try {
    // ---- Version single source ----
    // Ensure window.VERSION is defined and stamp it to any UI locations that show it.
    if (typeof window.VERSION === 'string') {
      var v = window.VERSION;
      var sv = document.getElementById('settingsVer'); if (sv) sv.textContent = 'v' + v;
      var mv = document.getElementById('menuVer'); if (mv) mv.textContent = 'v' + v;
      var t = document.querySelector('title');
      if (t && /v\d+\.\d+\.\d+/.test(t.textContent)) t.textContent = t.textContent.replace(/v\d+\.\d+\.\d+/, 'v' + v);
    }

    // ---- Settings event wiring (idempotent) ----
    if (!window.__settingsInitDone) {
      window.__settingsInitDone = true;
      var bind = function(id, key){
        var el = document.getElementById(id);
        if (!el || el._sbBound) return;
        el._sbBound = true;
        el.addEventListener('change', function(e){
          try {
            if (typeof SETTINGS === 'object') {
              SETTINGS[key] = !!e.target.checked;
              if (typeof _saveSettings === 'function') _saveSettings(SETTINGS);
              if (typeof applySettings === 'function') applySettings();
            }
          } catch(_){}
        });
      };
      bind('showCoords','showCoords');
      bind('showFPS','showFPS');
      bind('showDebugLine','showDebugLine');
      bind('showTravelLines','showTravelLines');
      bind('teleportToggle','teleportEnabled');
      bind('cheatsToggle','cheatsEnabled');
    }
  } catch(_){}
})();
</script>

<script>
// v0.0.93 patch: travel-line constraints & changelog
(function(){
  try {
    if (typeof CHANGELOG !== 'object' || CHANGELOG === null) { window.CHANGELOG = {}; }
    CHANGELOG["0.0.92"] = [
      "Unify version stamping across Title, Settings, and Menu.",
      "Make /tel numeric coords consistent with UI (sector→internal ×10).",
      "Consolidate Settings event wiring so toggles work immediately."
    ];
    CHANGELOG["0.0.93"] = [
      "Travel lines now form a first-visit chain only (no lines added on selection).",
      "Each star is limited to at most two travel lines; new systems link from the last new system only.",
      "A brand-new system initially has one line; its second appears when you discover the next new system."
    ];
  } catch(_){}
})();
</script>

<script>
// v0.0.93 changelog override (replace previous logs)
(function(){
  try {
    window.CHANGELOG = {
      "0.0.93": [
        "Travel lines persist correctly across reloads: loading a save no longer resets the path on subsequent warps.",
        "Travel lines follow first-visit chain only; revisits don’t add lines.",
        "Per-star cap: at most two travel lines per star; a brand-new system starts with one line to the previous new system."
      ]
    };
  } catch(_){}
})();
</script>

<script>
// v0.0.95: Changelog override (show this version only)
(function(){
  try {
    // Replace any previous entries entirely.  Only the latest version's notes are retained.
    window.CHANGELOG = {
      "0.0.95": [
        // Travel lines should persist when saving outside of hyperspace and reloading.
        "Fix: Travel lines no longer disappear when saving a game from ground or space. The full path now persists across multiple saves and reloads.",
        // Hide system dropdown when on the main menu.
        "Fix: The purple ‘Objects in System’ dropdown is now hidden on the main menu after saving, preventing it from lingering over the title screen.",
        // Bump version to .95.
        "Chore: Version bumped to 0.0.95 and previous change log entries removed."
      ]
    };
  } catch(_){}
})();
</script>
</body>
</html>

<script>
// v0.0.82: robust /tel X Y parser (works in hyperspace). Accepts "/tel x y", "/tel x, y", "/tel x,y"
(function(){
  function parseTel(cmd){
    if (!cmd || !/^\s*\/tel\b/i.test(cmd)) return null;
    var m = cmd.match(/^\s*\/tel\s+(-?\d+(?:\.\d+)?)\s*,?\s*(-?\d+(?:\.\d+)?)/i);
    if (!m) return null;
    return { x: Number(m[1]), y: Number(m[2]) };
  }
  function execCommand(cmd){
    try{
      var loc = parseTel(cmd);
      if (loc){
        if (!window.game || !window.STATE) { try{ toast('Game not ready.'); }catch(_){}; return; }
        if (game.state !== STATE.HYPER) { try{ toast('Teleport works only in hyperspace.'); }catch(_){}; return; }
        if (!game.galaxy || !game.galaxy.ship) return;
        // Stop any autopilot first
        game.galaxy.target = null;
        game.galaxy.freeTarget = null;
        // Teleport
        // Convert user-friendly sector coordinates to internal units by multiplying by 10. No offset is
        // necessary because the displayed hyperspace coordinates (ship.x/10, ship.y/10) should match the
        // entered values exactly. Reset any velocity to stop drift before teleporting.
        if (game.galaxy.ship){ game.galaxy.ship.vx = 0; game.galaxy.ship.vy = 0; }
        game.galaxy.ship.x = loc.x * 10;
        game.galaxy.ship.y = loc.y * 10;
        try{ toast('Teleported to '+loc.x+', '+loc.y); }catch(_){}
        return;
      }
    }catch(_){}
  }
  // Wire up command input if present
  document.addEventListener('DOMContentLoaded', function(){
    var input = document.getElementById('commandInput') || document.querySelector('#command input, #cmdInput');
    var btn = document.getElementById('cmdExecBtn');
    if (input){
      input.addEventListener('keydown', function(e){
        if (e.key === 'Enter') { execCommand(String(input.value||'')); input.select(); e.preventDefault(); }
      });
    }
    if (btn){
      btn.addEventListener('click', function(){ var t=(document.getElementById('commandInput')||{}).value||''; execCommand(String(t)); });
    }
  });
})();
</script>

<script>
// Ensure a Change Log chip is visible next to the Settings version
(function(){
  function ensureChangelogChip(){
    try{
      var title = document.querySelector('#settingsOverlay .title');
      if (!title) return;
      var verSpan = document.getElementById('settingsVer');
      var btn = document.getElementById('changelogBtn');
      if (!btn){
        btn = document.createElement('button');
        btn.id = 'changelogBtn';
        btn.type = 'button';
        btn.className = 'chipBtn';
        btn.textContent = 'Change Log';
        if (verSpan) verSpan.insertAdjacentElement('afterend', btn);
        else title.appendChild(btn);
      }
      // Always (re)attach handler.  At click time we check for the global
      // populateAndOpen function; if found, call it to build and display the
      // changelog overlay.  Otherwise fall back to simply showing the overlay.
      // Checking at click time avoids race conditions where the handler is
      // attached before populateAndOpen has been attached to window.
      btn.onclick = function(){
        // Invoke the global populateAndOpen if available.  If it has not yet
        // been defined, do nothing; the user can try again after the script
        // initializes.  Avoid falling back to the legacy overlay, which had
        // an unclosable "Close" button.
        var fn = window.populateAndOpen;
        if (typeof fn === 'function') { fn(); }
      };
    }catch(e){}
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', ensureChangelogChip);
  else ensureChangelogChip();
})();
</script>
